<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bash shell 环境变量</title>
    <url>/2020/10/20/bash_shell_env_variable/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>所谓<code>Bash Shell</code>的环境变量，指的就是<code>Bash Shell</code>存储的一些有关<code>shell</code>回话和工作环境的信息，它允许你在内存中储存数据，方便在脚本或者程序中访问这些信息。在<code>Bash Shell</code>环境变量中，分为<strong>全局变量</strong>和<strong>局部变量</strong>。  </p>
<ul>
<li><strong>全局变量：</strong>对<code>shell</code>会话和所有子<code>shell</code>会话都可见的环境变量；</li>
<li><strong>局部变量：</strong>仅对创建该环境变量的<code>shell</code>会话可见。</li>
</ul>
<h1 id="主要几个操作"><a href="#主要几个操作" class="headerlink" title="主要几个操作"></a>主要几个操作</h1><p>环境变量主要用到<strong>设置、查看和删除</strong>这3中操作。</p>
<p>设置环境变量直接直接使用<code>变量名=值</code>就完成了设置，注意不能够有空格，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=test1  <span class="comment"># 设置var环境变量，值为test1</span></span><br><span class="line">name=<span class="string">"this is test"</span>  <span class="comment"># 注意等号两边不能有空格，值有空格需要用双引号包住</span></span><br></pre></td></tr></table></figure>

<p>设置全局环境变量，需要用<code>export</code>命令，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> name  <span class="comment"># 名为name的环境变量导出为全局环境变量</span></span><br></pre></td></tr></table></figure>

<p>查看环境变量有<code>printenv</code>和<code>echo</code>命令，其中<code>printenv</code>命令只能查看全局环境变量，例如（注意<code>printenv</code>后直接接变量名，而<code>echo</code>则需要在变量名前面加<code>$</code>符号）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">printenv HOME</span><br><span class="line">ehco <span class="variable">$HOME</span></span><br><span class="line">printenv name</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$name</span></span><br><span class="line">printenv var  <span class="comment"># 这句将没有打印内容</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span></span><br></pre></td></tr></table></figure>

<p>单独使用<code>printenv</code>会打印全部全局变量。</p>
<p>如果要删除某个环境变量，则需要使用<code>unset</code>命令，但这个命令在删除全局变量时需要注意，在子<code>shell</code>中删除的全局变量在父<code>shell</code>中不起效，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unset</span> var  <span class="comment"># 删除var环境变量</span></span><br></pre></td></tr></table></figure>

<h1 id="系统加载"><a href="#系统加载" class="headerlink" title="系统加载"></a>系统加载</h1><p>当你启动系统登录时，系统会启动一个登录<code>shell</code>，登录<code>shell</code>会从以下几个文件中读取并执行命令：</p>
<ul>
<li>/etc/profile</li>
<li>$HOME/.bash_profile</li>
<li>$HOME/.bashrc</li>
<li>$HOME/.bash_login</li>
<li>$HOME/.profile</li>
</ul>
<p>其中<code>/etc/profile</code>是系统上默认的启动脚本文件，系统中每个用户登录的时候都会执行该脚本。后面的4个文件则会根据登录的用户相关设置进行执行。    </p>
<p>上面说的是系统登录的时候启动的登录<code>shell</code>，系统登录后启动一个交互<code>shell</code>的时候，它不会再访问<code>/etc/profile</code>文件了，而是会查找用户<code>HOME</code>目录下的<code>.bashrc</code>文件并执行，通常可以在该命令设置用户自定义相关的内容。  </p>
<p>实际上<code>/etc/profile</code>或者<code>.bashrc</code>两个文件还得看具体的<code>Linux</code>发行版，一些发行版可能以其他的命令，默认情况在这两个脚本中实际执行了什么动作，可以查看响应脚本的内容，例如，在<code>/etc/profile</code>中就有一段是扫描并执行<code>/etc/profile.d</code>中的<code>.sh</code>文件执行，因此可以添加用户自定义的<code>*.sh</code>脚本都该目录，实现登录时执行一些特定的命令。另外直接修改<code>/etc/profile</code>的话，修改的内容在系统更新的时候将会丢失，因此也不推荐直接修改改文件。</p>
<h1 id="进阶相关"><a href="#进阶相关" class="headerlink" title="进阶相关"></a>进阶相关</h1><p>上面所说的是环境变量的基本情况，有几个命令跟环境变量的操作也十分密切，分别是：<a href="https://man.linuxde.net/set" target="_blank" rel="noopener">set</a>、<a href="https://man.linuxde.net/env" target="_blank" rel="noopener">env</a>和<a href="https://man.linuxde.net/declare" target="_blank" rel="noopener">declare</a>。具体使用可以跳转到超链接相关页面查看，上面仅仅简单说明使用选项和举了简单的例子，可以在实际用到的时候测试用法并使用。</p>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Bash</tag>
        <tag>Shell</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Bash shell 函数</title>
    <url>/2020/10/20/bash_shell_function/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>函数是被赋予特定名字的代码块，可以再脚本中任意位置调用，合理地提取函数可以减少脚本代码的重复量，同时也方便去构建代码逻辑结构。在<code>Bash Shell</code>中，函数可以被理解为轻量级的脚本，执行函数类似与运行一个脚本，可以传递参数，也有返回值。</p>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h2><p>创建函数有两种方式，确切说是两种创建函数的语法，第一种是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> name &#123;</span><br><span class="line">    commands</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">name</span></span>() &#123;</span><br><span class="line">    commands</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的两种方式是等效的。</p>
<h2 id="调用和返回"><a href="#调用和返回" class="headerlink" title="调用和返回"></a>调用和返回</h2><p>创建函数后，调用函数和运行命令类似：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name [arg]</span><br></pre></td></tr></table></figure>

<p>上述为调用<code>name</code>函数，<code>arg</code>是传递给函数的参数。调用函数之后，将会以此执行<code>commands</code>中的命令，默认情况下，函数将以最后一个命令的退出状态码退出，该码保存在<code>$?</code>中，需要注意的是<code>$?</code>保存的是最新执行命令的退出状态码，因此如果需要该码一定要及时地读取和处理，以防被后续命令的退出状态码覆盖。</p>
<h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>利用函数的默认退出状态码，很不方便去获取函数执行完成后的状态，比如中途有个地方执行出错了，我对此一无所知。<code>Bash Shell</code>提供了<code>return</code>命令用来控制函数何时退出以及返回什么状态码（范围是0~255）。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">name</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> `ls /home/<span class="variable">$USER</span>/*`</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [ -f <span class="variable">$item</span> ]</span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">            filename=$(basename <span class="variable">$item</span>)</span><br><span class="line">            <span class="keyword">if</span> [[ <span class="variable">$filename</span> = <span class="string">"test.sh"</span> ]]</span><br><span class="line">            <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">return</span> 10</span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">return</span> 20</span><br><span class="line">&#125;</span><br><span class="line">name</span><br><span class="line">status=$?</span><br><span class="line"><span class="keyword">if</span> (( status == 10 ))</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Found，status=<span class="variable">$status</span>, path=<span class="variable">$item</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Not Found, status=<span class="variable">$status</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h3 id="返回任意内容"><a href="#返回任意内容" class="headerlink" title="返回任意内容"></a>返回任意内容</h3><p>上述的<code>return</code>命令虽然可以控制函数的终止和退出状态码，但是就是上面所述，很明显有着很大的限制。除了<code>return</code>外，我们还有另外一种方式来返回数据，也就是利用函数中的输出，在调用函数的时候可以利用一个变量来捕获函数中的输出，从而达到返回的效果。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> name &#123;</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> `ls /home/<span class="variable">$USER</span>/*`</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [ -f <span class="variable">$item</span> ]</span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">            filename=$(basename <span class="variable">$item</span>)</span><br><span class="line">            <span class="keyword">if</span> [[ <span class="variable">$filename</span> = <span class="string">"test.sh"</span> ]]</span><br><span class="line">            <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"success"</span></span><br><span class="line">                <span class="built_in">return</span> 10</span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"fail"</span></span><br><span class="line">    <span class="built_in">return</span> 20</span><br><span class="line">&#125;</span><br><span class="line">msg=`name`</span><br><span class="line">status=$?</span><br><span class="line"><span class="keyword">if</span> (( status == 10 ))</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$msg</span>，status=<span class="variable">$status</span>, path=<span class="variable">$item</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$msg</span>, status=<span class="variable">$status</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>上述利用<code>msg</code>变量捕获了<code>name</code>函数的输出，再结合<code>return</code>命令，可以很好的对函数进行控制。需要注意的是，<code>msg</code>会捕获函数中的基本所有输出，除了一些命令如<code>read</code>设置的提示输入字符，所以使用的时候需要留心。  </p>
<p>了解了后面讲述的作用域之后，很明显还可以用全局变量来获取函数中的数据当作返回值，但是这样子一定要相当留心。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>和很多变成语言一样，变量通常都有作用域，即变量在规定的作用域才会有意义，作用域定义了变量的可见区域。函数中分有<strong>全局变量</strong>和<strong>局部变量</strong>，全局变量在脚本中全局可见，而局部变量则只在其定义的函数中可见。  </p>
<p>在脚本函数外定义的变量就是全局变量，在任何地方都可以访问到。而在函数内部定义的变量，则是局部变量，只能函数内部可见。例如：</p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"before set: <span class="variable">$global_value</span>"</span></span><br><span class="line">    global_value=$[ <span class="variable">$global_value</span> + 1 ]</span><br><span class="line">&#125;</span><br><span class="line">global_value=5</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"init: <span class="variable">$global_value</span>"</span></span><br><span class="line">func</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"after set: <span class="variable">$global_value</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出为：</span></span><br><span class="line"><span class="comment"># init: 5</span></span><br><span class="line"><span class="comment"># before set: 5</span></span><br><span class="line"><span class="comment"># after set: 6</span></span><br></pre></td></tr></table></figure>

<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">    global_value=5</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"init in function: <span class="variable">$global_value</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"get in global: <span class="variable">$global_value</span>"</span></span><br><span class="line">func</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出为：</span></span><br><span class="line"><span class="comment"># get in global:</span></span><br><span class="line"><span class="comment"># init in function: 5</span></span><br></pre></td></tr></table></figure>

<p>可以看出，函数内部可以访问全局变量，而函数内部的变量外部无法访问。</p>
<h3 id="local命令"><a href="#local命令" class="headerlink" title="local命令"></a>local命令</h3><p><code>local</code>命令可以函数内指定某个变量为局部变量，即便该变量和全局变量同名。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"before set: <span class="variable">$global_value</span>"</span></span><br><span class="line">    <span class="built_in">local</span> global_value=$[ <span class="variable">$global_value</span> + 1 ]</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"after local set: <span class="variable">$global_value</span>"</span></span><br><span class="line">&#125;</span><br><span class="line">global_value=5</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"init: <span class="variable">$global_value</span>"</span></span><br><span class="line">func</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"after set: <span class="variable">$global_value</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出为：</span></span><br><span class="line"><span class="comment"># init: 5</span></span><br><span class="line"><span class="comment"># before set: 5</span></span><br><span class="line"><span class="comment"># after local set: 6</span></span><br><span class="line"><span class="comment"># after set: 5</span></span><br></pre></td></tr></table></figure>

<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>和一开始讲到那样，函数就像是轻量级的命令，同样的，函数传递参数和命令传递参数是一样的，就是在函数内获取参数，也是同样的获取方法，用一些特殊变量来保存这些参数。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"\$0: <span class="variable">$0</span>"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"\$#: <span class="variable">$#</span>"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"\$@: <span class="variable">$@</span>"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"\$*: $*"</span></span><br><span class="line">    <span class="keyword">for</span> (( i = 1; i &lt; <span class="variable">$#</span>; i++ ))</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"\$<span class="variable">$&#123;i&#125;</span>: <span class="variable">$&#123;!i&#125;</span>"</span>  <span class="comment"># 大括号中不能用$符号，用!代替</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line">func first second</span><br><span class="line"><span class="comment"># 输出为：</span></span><br><span class="line"><span class="comment"># $0: ./shell/test.sh</span></span><br><span class="line"><span class="comment"># $#: 2</span></span><br><span class="line"><span class="comment"># $@: first second</span></span><br><span class="line"><span class="comment"># $*: first second</span></span><br><span class="line"><span class="comment"># $1: first</span></span><br><span class="line"><span class="comment"># $2: second</span></span><br></pre></td></tr></table></figure>

<p>可以看见，除了<code>$0</code>还是表示脚本名称外，其他的都表示与函数传入参数相关的信息了。如果在函数中使用<code>shift</code>命令，那么将对函数的传入参数进行移位。</p>
<h2 id="导入外部脚本"><a href="#导入外部脚本" class="headerlink" title="导入外部脚本"></a>导入外部脚本</h2><p>通常的，对于比较复杂的脚本，我们可以将脚本拆分为多个，然后将其导入到其他脚本中，以方便代码组织。很常用的一种就是创建单独的库文件，里面放一些通用的函数。主要难点在于如何将一个脚本导入另一个脚本中。这里要用到的就是<code>source</code>命令，也就是所谓的点操作符。我们可以在一个脚本中使用<code>source filename</code>导入其他脚本，之所所称为点操作符，因为<code>source filename</code>和<code>. filename</code>是等效的。加入有脚本文件名为<code>myshelllib</code>如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="built_in">test</span> &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"my lib function"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面同一目录下的<code>test.sh</code>需要用上面的函数，则<code>test.sh</code>可以如下引入库中的函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> myshelllib  <span class="comment">#或者：. myshelllib</span></span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Bash</tag>
        <tag>Shell</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Bash shell 参数处理</title>
    <url>/2020/10/20/bash_shell_opt/</url>
    <content><![CDATA[<h1 id="参数的处理方法"><a href="#参数的处理方法" class="headerlink" title="参数的处理方法"></a>参数的处理方法</h1><p>和命令的选项和参数一样，执行脚本的时候可以指定传进来的选项和参数，什么是选项什么是参数就不多说了。向<code>Shell</code>中传递的参数叫<strong>命令行参数</strong>，传进来的参数将会被赋值给一些特殊变量，这些变量称为<strong>位置参数</strong>，这些变量利用数字表示，其中<code>$0</code>表示命令名称，<code>$1</code>表示第一个参数，<code>$2</code>表示第二个参数，以此类推。如果参数很多，比如15个，那么最后一个参数用<code>${15}</code>表示，注意要用大括号，传入的参数之间用空格分隔。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Script name is: <span class="variable">$0</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"First paramerter is: <span class="variable">$1</span>"</span></span><br></pre></td></tr></table></figure>

<p>执行上述脚本就会打印脚本名称和第一个参数了。如下所示：</p>
<p><img src="/2020/10/20/bash_shell_opt/zero_parameter.png" alt="脚本参数"></p>
<p>可以看到<code>$0</code>实际上是包含了脚本的完整路径的，对此，可以利用<code>basename</code>命令获取脚本名称。如下处理，就可以获取脚本名了（带后缀）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name=$(basename <span class="string">"<span class="variable">$0</span>"</span>)  <span class="comment"># 添加双引号以防路径中有空格</span></span><br></pre></td></tr></table></figure>

<p>此外，传如的参数处理上述的特殊变量外，还有几个特殊变量与参数相关，分别是（都不包括<code>$0</code>）：</p>
<ul>
<li><code>$#</code>：表示参数的个数；</li>
<li><code>$*</code>：表示传进来的所有参数，是一个整体；</li>
<li><code>$@</code>：表示传进来的所有参数，与第二个区别是，这里每个参数单独是一个个体。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="string">"$*"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$item</span>  <span class="comment"># 最多之后一次进入执行，一次输出全部参数</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$item</span>  <span class="comment"># 循环$#次，每次输出一个参数</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h2 id="参数处理"><a href="#参数处理" class="headerlink" title="参数处理"></a>参数处理</h2><p>参数处理其实可以有很多方式，比如直接对<code>$@</code>遍历，或者利用<code>$#</code>计数循环，每次都拿出一个参数进行判断处理。但是，这种处理方式很不方便，稍微复杂一点的参数处理起来就很麻烦了。通常可以利用<code>shift</code>、<code>getopt</code>和<code>getopts</code>对参数进行处理。</p>
<h2 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h2><p><code>shift</code>是移位命令，可以对传入参数进行左移，后面可以带一个整数表示左移多少个，默认是<code>1</code>。左移一位就是，原来的<code>$3</code>变成了<code>$2</code>，<code>$2</code>变成了<code>$1</code>，<code>$1</code>将被丢弃，其他的情况类似，<code>$0</code>始终不变。例如下面脚本将会不断输出传入的参数，直到全部输出位置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Found Parameter: <span class="variable">$1</span>"</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，执行<code>shift</code>之后，丢弃的参数将不可恢复。通常会结合<code>case</code>命令一起，达到处理不同参数的效果:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></span><br><span class="line">    -a) <span class="built_in">echo</span> <span class="string">"do \"a\" job"</span>;;</span><br><span class="line">    -b) <span class="built_in">echo</span> <span class="string">"do \"b\" job"</span>;;</span><br><span class="line">    *) <span class="built_in">echo</span> <span class="string">"unknown job: <span class="variable">$1</span>"</span>;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>上述脚本将支持两个选项，<code>-a</code>和<code>-b</code>，比如其名称是<code>test.sh</code>，可以这样执行: <code>./test.sh -a -b</code>，从而达到达到了处理参数选项的效果。</p>
<h2 id="getopt"><a href="#getopt" class="headerlink" title="getopt"></a>getopt</h2><p><code>getopt</code>命令用户对输入参数的调整，使得处理起来更方便，其基本使用方法为:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">getopt option optstring parameter</span><br></pre></td></tr></table></figure>

<p>执行<code>getopt</code>命令后将输出调整后的参数，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">getopt ab:c -a test1 -b test2 -c test3 test4</span><br><span class="line"><span class="comment"># 输出为：</span></span><br><span class="line"><span class="comment"># -a -b test2 -c -- test1 test3 test4</span></span><br></pre></td></tr></table></figure>

<p>可以看见输出后得到的参数更加规范，下面对<code>optstring</code>进行简要说明。<code>optstring</code>定义了选项有哪些以及那些选项带有参数。具体格式是，各个选项字母组成的字符串，某个选项需要带参数的则在对应字母后面加一个冒号（一个表示必选参数，两个表示可选），最终得到的字母和冒号组成的字符串就是<code>optstring</code>了。  </p>
<p>此外，<code>getopt</code>还支持长选项，类似于单字母选项，如下例子（用<code>-l</code>指定长选项<code>optstring</code>）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">getopt -o a -l along,blong:,clong:: -- --along --blong=1 --clong <span class="built_in">test</span> -a</span><br><span class="line"><span class="comment"># 输出为：</span></span><br><span class="line"><span class="comment"># --along --blong '1' --clong '' -a -- 'test'</span></span><br></pre></td></tr></table></figure>

<p><code>optstring</code>类似于单字母选项，仅仅是选项之间用逗号分隔，其他规则一样。有了这些理解，详细的使用方法可以查看命令手册，在终端执行<code>man getopt</code>即可查看。</p>
<p><code>optget</code>命令得到的输出按<code>optstring</code>，选项和参数以此排列，如上述例子。需要注意的是，该命令不能处理参数中的空格，即便加了双引号也会当成两个参数。最后需要说明的是，命令行中的破折号（两个连续的减号）参数，表示的是其后面的全部是参数，没有选项，即便写成<code>-a</code>这种形式，也不会把它当选项处理，只看做是参数。  </p>
<p>有了<code>getopt</code>命令的参数调整，需要用<code>set</code>命令将这些参数覆盖掉特殊变量中的参数，具体为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -- parameter</span><br></pre></td></tr></table></figure>

<p>表示用<code>parameter</code>替换掉原来的命令行参数。因此，结合<code>getopt</code>，可以这样替换原来的参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -- $(getopt option optstring <span class="string">"<span class="variable">$@</span>"</span>)</span><br></pre></td></tr></table></figure>

<p>这样一来，诸如<code>$1</code>这些特殊变量就按照<code>getopt</code>命令输出内容决定了。然后结合<code>shift</code>和<code>case</code>，参数处理起来就简便了不少。</p>
<h2 id="getopts"><a href="#getopts" class="headerlink" title="getopts"></a>getopts</h2><p><code>getopts</code>是另外一个参数处理命令，其使用方法为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">getopts</span> optstring variable [arg]</span><br></pre></td></tr></table></figure>

<p>每次得到待处理的选项赋值给上述的<code>variable</code>。其中<code>optstring</code>格式和<code>getopt</code>类似。如果需要禁用错误输出，只需<code>optstring</code>以冒号开头即可。  </p>
<p>需要注意的是：</p>
<ul>
<li>得到的选项将不包含开头的<code>-</code>，比如有<code>-a</code>选项，则变量<code>variable</code>中的值是<code>a</code>。如果某个选项不在<code>optstring</code>定义的选项中，则<code>variable</code>中存的值统一都是<code>?</code>（问号）；</li>
<li><code>getopts</code>不支持长选项，支持多个选项放一起，如<code>-ac</code>和<code>-a -c</code>一样效果；</li>
<li><code>getopts</code>参数和选项之间可以没有空格，如<code>-aarg</code>和<code>-a arg</code>一样；</li>
<li><code>getopts</code>能够识别出双引号参数中的空格，即不会当成多个参数处理。</li>
</ul>
<p>当<code>getopts</code>待处理的下一个参数不是选项时，<code>getopts</code>就以非零退出状态退出了，所幸，<code>getopts</code>还提供了另外一个环境变量：<code>OPTIND</code>，保存的是一个整数，表示了待处理的下一个参数所在的位置，利用该环境变量，就可以很方便获取上下没出来那些没有对应选项的参数。下面是一个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> a:bc:d opt</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$opt</span> = <span class="string">"?"</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"unknown option: <span class="variable">$opt</span>"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Found option: <span class="variable">$opt</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">shift</span> $[ <span class="variable">$OPTIND</span> - 1 ]</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Rest parameters: <span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure>

<p>上面的例子因为遇到第一个非选项的参数的时候就退出循环了，而利用<code>getopt</code>的特性：把所有选项都调整在前面，因此可以结合两个命令一起用，效果就比较好了，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -- `getopt a:bc:d <span class="string">"<span class="variable">$@</span>"</span>`</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> a:bc:d opt</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$opt</span> = <span class="string">"?"</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"unknown option: <span class="variable">$opt</span>"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Found option: <span class="variable">$opt</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">shift</span> $[ <span class="variable">$OPTIND</span> - 1 ]</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Rest parameters: <span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure>

<p>这样的话在循环中就可以处理完所有参数，而剩下的无选项参数全部放在了最后。</p>
<p><strong>注意：</strong> 这里因为先用到了<code>getopt</code>调整参数，因此参数需要满足其使用特征，例如不支持选项和参数之间没有空格等等这种仅仅<code>getopts</code>支持的特征。</p>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Bash</tag>
        <tag>Shell</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Bash shell 流程控制——条件控制</title>
    <url>/2020/10/20/bash_shell_structure/</url>
    <content><![CDATA[<h1 id="条件控制语句"><a href="#条件控制语句" class="headerlink" title="条件控制语句"></a>条件控制语句</h1><p>基本语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">command</span>  <span class="comment"># 该命令退出状态码为0时为真</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>或者也可以：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">command</span>; <span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>带<code>else</code>的格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">command</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>带<code>elif</code>的格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">command</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">command</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>可以执行多个<code>elif</code>，同时，最后一个<code>elif</code>后面可以继续接<code>else</code>，从而达到复杂的条件分支执行效果。  </p>
<p>与其他编程语言不同的是，<code>Bash Shell</code>中<code>if</code>后面跟的是一个命令，当执行到该行的时候，如果命令执行后退出状态码为<code>0</code>，则会认为是<code>TRUE</code>，继而执行<code>then</code>后面的命令，否则，即退出状态码非零，将认为是<code>FALSE</code>，<code>then</code>后面的命令将不被执行。在终端中可以执行一个命令后，紧接着执行<code>echo $?</code>便可以显示上一个命令的退出状态码了。</p>
<h1 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h1><p><code>Bash Shell</code>提供了<code>if</code>条件控制，但是条件只能是一个命令，根据其退出状态码决定真假，这使得用起来收到了很大限制。<code>test</code>提供了测试不同条件的途径，准确说还是上述<code>if</code>的用法，只不过<code>test</code>命令可以对其测试的条件进行判断，根据条件的真假适当返回执行后的退出状态码，从而达到根据条件执行分支的效果。<code>test</code>命令的格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">test</span> condition</span><br></pre></td></tr></table></figure>

<p><code>condition</code>即为<code>test</code>命令测试的条件，条件为真，则<code>test</code>返回退出状态码为<code>0</code>，否则为非零。因此，<code>if</code>条件控制的写法可以写成（其他类似）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> condition; <span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>此外，<code>Bash</code>提供了另外一种方便的写法，上述格式等效于：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ]; <span class="keyword">then</span> <span class="comment"># 注意方括号两边内侧的空格</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>至于<code>condition</code>可以写啥，可以执行<code>man test</code>命令查看命令手册，上面有较为详细的说明，下面对各种情况下的条件进行总结。</p>
<h1 id="test命令条件格式"><a href="#test命令条件格式" class="headerlink" title="test命令条件格式"></a>test命令条件格式</h1><h2 id="数值比较"><a href="#数值比较" class="headerlink" title="数值比较"></a>数值比较</h2><p>数据比较的操作有如下表格中的几操作：</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-eq</td>
<td align="center"><code>equal</code>等于</td>
</tr>
<tr>
<td align="center">-ge</td>
<td align="center"><code>greater equal</code>大于等于</td>
</tr>
<tr>
<td align="center">-gt</td>
<td align="center"><code>greater than</code>大于</td>
</tr>
<tr>
<td align="center">-le</td>
<td align="center"><code>less equal</code>小于等于</td>
</tr>
<tr>
<td align="center">-lt</td>
<td align="center"><code>less than</code>小于</td>
</tr>
<tr>
<td align="center">-ne</td>
<td align="center"><code>not equal</code>不等于</td>
</tr>
</tbody></table>
<p>上述符号的使用格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ int1 -xx int2 ]</span><br></pre></td></tr></table></figure>

<p>表示整数<code>int1</code>和整数<code>int2</code>比较，<code>-xx</code>为比较符号，结果与条件真假相同。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 8 -gt 5 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"true"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>上述脚本判断<code>8大于5</code>的真假性，根据得到的结果选择是否执行后续命令，显然条件结果为真，因此执行后续命令<code>echo &quot;true&quot;</code>。</p>
<h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><p>字符串比较有下表几种操作：</p>
<table>
<thead>
<tr>
<th align="center">用法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>[ str1 = str2 ]</code></td>
<td align="center">相同</td>
</tr>
<tr>
<td align="center"><code>[ str1 != str2 ]</code></td>
<td align="center">不相同</td>
</tr>
<tr>
<td align="center"><code>[ str1 \&gt; str2 ]</code></td>
<td align="center">大于</td>
</tr>
<tr>
<td align="center"><code>[ str1 \&lt; str2 ]</code></td>
<td align="center">小于</td>
</tr>
<tr>
<td align="center"><code>[ -n str ]</code></td>
<td align="center">字符串长度不为0</td>
</tr>
<tr>
<td align="center"><code>[ -z str ]</code></td>
<td align="center">字符串长度为0</td>
</tr>
</tbody></table>
<p><strong>需要注意的是字符串大小判断需要注意两点：</strong></p>
<ul>
<li>大于号和小于号必须转义，否则将会被视作重定向符，从而导致严重错误；</li>
<li>大于和小于顺序和<code>sort</code>命令采取的不同。主要是因为<code>sort</code>命令处理大写字母的方法刚好和<code>test</code>命令相反，即<code>test</code>认为大写字母小于小写字母，而<code>sort</code>则反之。</li>
</ul>
<h2 id="文件比较"><a href="#文件比较" class="headerlink" title="文件比较"></a>文件比较</h2><p>字符串比较有下表几种操作：</p>
<table>
<thead>
<tr>
<th align="center">用法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>[ -d file ]</code></td>
<td align="left">是否是目录</td>
</tr>
<tr>
<td align="center"><code>[ -e file ]</code></td>
<td align="left">是否存在</td>
</tr>
<tr>
<td align="center"><code>[ -f file ]</code></td>
<td align="left">是否是文件</td>
</tr>
<tr>
<td align="center"><code>[ -r file ]</code></td>
<td align="left">是否可读</td>
</tr>
<tr>
<td align="center"><code>[ -s file ]</code></td>
<td align="left">是否非空</td>
</tr>
<tr>
<td align="center"><code>[ -w file ]</code></td>
<td align="left">是否可写</td>
</tr>
<tr>
<td align="center"><code>[ -x file ]</code></td>
<td align="left">是否可执行</td>
</tr>
<tr>
<td align="center"><code>[ -O file ]</code></td>
<td align="left">是否当前用户所有</td>
</tr>
<tr>
<td align="center"><code>[ -G file ]</code></td>
<td align="left">文件归属组是否与当前用户所在组相同</td>
</tr>
<tr>
<td align="center"><code>[ file1 -nt file2 ]</code></td>
<td align="left"><code>newer than</code>文件1比文件2新</td>
</tr>
<tr>
<td align="center"><code>[ file1 -ot file2 ]</code></td>
<td align="left"><code>older than</code>文件1比文件2旧</td>
</tr>
</tbody></table>
<p><strong>注意：</strong>除<code>-e</code>外，其他命令当文件不存在时条件的结果均为假，即文件必须存在才有可能条件为真。</p>
<h1 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h1><p><code>if</code>条件控制可以测试复合条件，即进行布尔运算，有以下两种用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ condition1 ] &amp;&amp; [ condition2 ]  <span class="comment"># 与运算</span></span><br><span class="line">[ condition1 ] || [ condition2 ]  <span class="comment"># 或运算</span></span><br></pre></td></tr></table></figure>

<h1 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h1><h2 id="使用双括号"><a href="#使用双括号" class="headerlink" title="使用双括号"></a>使用双括号</h2><p>双括号命令提供了使用高级数学表达式的便捷方式，除了提供标准的加减乘除和比较之外，还提供了下表中的运算（双括号中的大于小于号不用转义）：</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>val++</code></td>
<td align="left">后增</td>
</tr>
<tr>
<td align="center"><code>val--</code></td>
<td align="left">后减</td>
</tr>
<tr>
<td align="center"><code>++val</code></td>
<td align="left">先增</td>
</tr>
<tr>
<td align="center"><code>--val</code></td>
<td align="left">先减</td>
</tr>
<tr>
<td align="center"><code>!</code></td>
<td align="left">逻辑求反</td>
</tr>
<tr>
<td align="center"><code>~</code></td>
<td align="left">位求反</td>
</tr>
<tr>
<td align="center"><code>**</code></td>
<td align="left">求幂</td>
</tr>
<tr>
<td align="center"><code>&lt;&lt;</code></td>
<td align="left">左移</td>
</tr>
<tr>
<td align="center"><code>&gt;&gt;</code></td>
<td align="left">右移</td>
</tr>
<tr>
<td align="center"><code>&amp;</code></td>
<td align="left">位与</td>
</tr>
<tr>
<td align="center">`</td>
<td align="left">`</td>
</tr>
<tr>
<td align="center"><code>&amp;&amp;</code></td>
<td align="left">逻辑与</td>
</tr>
<tr>
<td align="center">`</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>注意：</strong>使用中注意空格</p>
<h2 id="使用双方括号"><a href="#使用双方括号" class="headerlink" title="使用双方括号"></a>使用双方括号</h2><p>双方括号提供了字符串比较的高级用法，不仅提供了<code>test</code>中字符串的标准用法，<strong>还提供正则匹配的用法</strong>，格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[[ expression ]]</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ <span class="string">"rich"</span> == r* ]]; <span class="keyword">then</span>  <span class="comment"># 这里正则匹配，结果为真</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"true"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 不是所有<code>Shell</code>都支持双方括号</p>
<h2 id="case命令"><a href="#case命令" class="headerlink" title="case命令"></a>case命令</h2><p><code>case</code>类似于很多变成语言中的<code>switch</code>，是一种分支控制结构，可以简化很多嵌套<code>if</code>的使用情况。使用格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> variable <span class="keyword">in</span></span><br><span class="line">pattern1 | pattern2)</span><br><span class="line">    commands1;;</span><br><span class="line">pattern3)</span><br><span class="line">    commands2;;</span><br><span class="line">*)  <span class="comment"># default</span></span><br><span class="line">    commands;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Bash</tag>
        <tag>Shell</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Bash shell 流程控制——循环控制</title>
    <url>/2020/10/14/bash_shell_structure_for/</url>
    <content><![CDATA[<h1 id="循环控制结构"><a href="#循环控制结构" class="headerlink" title="循环控制结构"></a>循环控制结构</h1><p>循环控制是很多编程语言中的重要控制结构，主要用于控制重复执行的代码块。在<code>Bash Shell</code>中循环控制有3个命令，分别是<code>for</code>、<code>while</code>和<code>until</code>。同时也有<code>break</code>和<code>continue</code>两个命令用于干预循环结构的执行。下面首先讲解命令的使用语法，然后讲几点高级用法或者说特殊的使用方法。</p>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p><code>for</code>循环的基本语法是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> list  <span class="comment"># 可以与do放在一行，但是要用一个分号隔开，如下</span></span><br><span class="line"><span class="keyword">do</span>               <span class="comment"># for var in list; do</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">list=<span class="string">"I LOVE YOU"</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> <span class="variable">$list</span>  <span class="comment"># 或者直接是：for var in I LOVE YOU</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 将会输出:</span></span><br><span class="line"><span class="comment"># I</span></span><br><span class="line"><span class="comment"># LOVE</span></span><br><span class="line"><span class="comment"># YOU</span></span><br></pre></td></tr></table></figure>

<h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p><code>while</code>循环的基本语法是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">command</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><code>while</code>循环如同条件控制<code>if</code>一样是需要利用命令的退出状态码判断，当<code>command</code>执行退出状态码为<code>0</code>时，将继续执行循环，否则退出循环。<code>command</code>和<code>if</code>一样可以用<code>test</code>命令或者方括号等使用方法。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=2</span><br><span class="line"><span class="keyword">while</span> (( var-- &gt; 0 ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 将会输出：</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 0</span></span><br></pre></td></tr></table></figure>

<h2 id="until"><a href="#until" class="headerlink" title="until"></a>until</h2><p><code>until</code>循环的基本语法是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">until <span class="built_in">command</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><code>until</code>语法和<code>while</code>完全一样，但是规则确实相反的，<code>until</code>是直到<code>command</code>退出状态码为<code>0</code>的时候退出循环，而在非零的时候进入循环。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=0</span><br><span class="line">until (( var++ &gt; 2 ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 将会输出：</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure>

<h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p><code>break</code>命令用于退出循环，即在循环中遇到<code>break</code>命令的时候将跳出，这一点和很多编程语言是一致的。而在<code>Bash Shell</code>中，可以指定<code>break</code>跳出那一层循环，格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">break</span> n</span><br></pre></td></tr></table></figure>

<p>其中<code>n</code>表示的就是跳出第几层循环，默认为<code>1</code>表示当前层，<code>2</code>表示当前层的外一层，以此类推。</p>
<h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p><code>continue</code>命令和<code>break</code>用法语法完全一致，不一样在于，循环中遇到<code>continue</code>不是退出循环，而是跳过<code>continue</code>命令直接进入下一次循环判断。同样的，可以后接一个参数指定跳出的是那一层循环。</p>
<h1 id="其他几个用法"><a href="#其他几个用法" class="headerlink" title="其他几个用法"></a>其他几个用法</h1><h2 id="遍历目录中所有文件"><a href="#遍历目录中所有文件" class="headerlink" title="遍历目录中所有文件"></a>遍历目录中所有文件</h2><p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> path <span class="keyword">in</span> /home/ubuntu/* <span class="comment"># 可以放多个目录，用空格分开</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="variable">$path</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$path</span> is a directory"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$path</span> is a file"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h2 id="for的C-Style格式"><a href="#for的C-Style格式" class="headerlink" title="for的C-Style格式"></a>for的C-Style格式</h2><p><code>for</code>循环可以类似<code>C</code>语言的写法，格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (( variable assignment ; condition ; iteration process ))</span><br></pre></td></tr></table></figure>

<p>这里有几项不遵循<code>Bash Shell</code>的<code>for</code>方法：</p>
<ul>
<li>变量的赋值可以包含空格；</li>
<li>条件中的变量不以<code>$</code>做前缀；</li>
<li>迭代处理不用使用<code>expr</code>命令格式。</li>
</ul>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (( i=1; i &lt;= 10; i++ ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>可以使用多个变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (( i=1, j=10 ; i &lt;= 10; i++, j-- ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$i</span>, <span class="variable">$j</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h2 id="处理循环的输出"><a href="#处理循环的输出" class="headerlink" title="处理循环的输出"></a>处理循环的输出</h2><p>循环的输出默认会输出到终端直接显示出来，我们可以将循环中的输出重定向到指定的文件中。做法就是在循环语句中的<code>done</code>后面加重定向操作。如下就可以把循环中所有的输出重定向到<code>output.txt</code>文件中了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (( i=1, j=10 ; i &lt;= 10; i++, j-- ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$i</span>, <span class="variable">$j</span>"</span></span><br><span class="line"><span class="keyword">done</span> &gt; output.txt</span><br></pre></td></tr></table></figure>

<h2 id="while和until执行多条命令"><a href="#while和until执行多条命令" class="headerlink" title="while和until执行多条命令"></a>while和until执行多条命令</h2><p><code>while</code>和<code>until</code>中的<code>command</code>处可以放置多条命令，但是最终结果有最后一条命令决定循环的执行。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=0</span><br><span class="line">until <span class="built_in">echo</span> <span class="string">"var=<span class="variable">$var</span>"</span>     <span class="comment"># 或者用逗号(;)将多个命令分开，如下效果是一样的：</span></span><br><span class="line">        (( var++ &gt; 2 ))   <span class="comment"># until echo "var=$var" (( var++ &gt; 2 ))</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Bash</tag>
        <tag>Shell</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>常用概率论基本概念</title>
    <url>/2020/03/11/basic_concept_of_probability/</url>
    <content><![CDATA[<h1 id="概率分布与概率密度"><a href="#概率分布与概率密度" class="headerlink" title="概率分布与概率密度"></a>概率分布与概率密度</h1><p>对于随机变量$X$来说，它可以是离散的也可以是连续的。  </p>
<h2 id="离散随机变量"><a href="#离散随机变量" class="headerlink" title="离散随机变量"></a>离散随机变量</h2><p>离散的情况下，我们用概率分布来描述$X$，记为  </p>
<p>$$p(x_i) = P(X=x_i) \quad (i=1,2,3,\dots,n)$$</p>
<p>其中，$P(X=x_i)$表示$X$取$x_i$的概率。<br>且有<br>$$p(x_i) \geq 0$$<br>$$\sum_{i=1}^n p(x_i) = 1$$</p>
<h2 id="连续随机变量"><a href="#连续随机变量" class="headerlink" title="连续随机变量"></a>连续随机变量</h2><p>连续的情况下，我们通常用概率密度刻画随机变量$X$，记为  </p>
<p>$$p(x)=f(x)$$</p>
<p>且有  </p>
<p>$$\int p(x)=1$$</p>
<p>分布函数记为  </p>
<p>$$P(X&lt;x)=\int_{-\infty}^x p(x)dx$$  </p>
<p>$P(X&lt;x)$表示$X&lt;x$的概率 </p>
<h1 id="高斯分布"><a href="#高斯分布" class="headerlink" title="高斯分布"></a>高斯分布</h1><p>在数理统计中最常见的分布就是高斯分布了，在很多概率模型中都用到该分布。</p>
<h2 id="一维高斯分布"><a href="#一维高斯分布" class="headerlink" title="一维高斯分布"></a>一维高斯分布</h2><p>一维高斯分布密度函数为  </p>
<p>$$p(x) = {(2\pi\sigma)}^{-\frac{1}{2}}exp\left\lbrace-\frac{1}{2}\frac{(x-\mu)^2}{\sigma^2}\right\rbrace$$  </p>
<p>记为$X \backsim \mathcal{N}(x;\mu,\sigma^2)$，其中$\mu$表示高斯分布的均值，$\sigma^2$表示高斯分布的方差。  </p>
<h2 id="多维高斯分布"><a href="#多维高斯分布" class="headerlink" title="多维高斯分布"></a>多维高斯分布</h2><p>当多维随机变量服从高斯分布时，我们记为<br>$$p(\mathbf{x})=det(2\pi\mathbf{\Sigma})^{-\frac{1}{2}}\exp\left\lbrace-\frac{1}{2}(\mathbf{x}-\mathbf{\mu})^\mathbf{T}\mathbf{\Sigma}^{-1}(\mathbf{x}-\mathbf{\mu})\right\rbrace$$<br>其中，$\mathbf{x}=\begin{bmatrix}x_1 &amp; x_2 &amp; \dots &amp; x_n\end{bmatrix}^\mathbf{T}$为随机向量,$\mathbf{\mu}=\begin{bmatrix}\mu_1 &amp; \mu_2 &amp; \dots &amp; \mu_n\end{bmatrix}^\mathbf{T}$<br>为随机向量的均值，$\mathbf{\Sigma}=\begin{bmatrix}\sigma_{11} &amp; \sigma_{12} &amp; \dots &amp; \sigma_{1n} \\ \sigma_{21} &amp; \sigma_{22} &amp; \dots &amp; \sigma_{2n} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ \sigma_{n1} &amp; \sigma_{n2} &amp; \dots &amp; \sigma_{nn} \end{bmatrix}$为随机向量的协方差矩阵。  </p>
<p>可以看出，一维高斯分布是多维高斯分布的特例，多维高斯分布是一维高斯分布的扩展。</p>
<h1 id="联合分布"><a href="#联合分布" class="headerlink" title="联合分布"></a>联合分布</h1><p>对于两个随机变量$X$和$Y$来说，它们的联合分布表示为<br>$$p(x,y)=P(X=x,Y=y)$$</p>
<h2 id="随机变量的独立性"><a href="#随机变量的独立性" class="headerlink" title="随机变量的独立性"></a>随机变量的独立性</h2><p>如果两个随机变量相互独立，则有<br>$$p(x,y)=p(x)p(y)$$</p>
<h2 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h2><p>我们记随机变量$X$在$Y$的条件下的概率为<br>$$p(x|y)=p(X=x|Y=y)$$<br>若$p(y)&gt;0$，我们有<br>$$p(x|y)=\frac{p(x,y)}{p(y)}$$<br>若$X$和$Y$相互独立，则有<br>$$p(x|y)=p(x)$$  </p>
<h1 id="全概率公式"><a href="#全概率公式" class="headerlink" title="全概率公式"></a>全概率公式</h1><p>对于离散随机变量，为<br>$$p(x)=\sum_y p(x|y)p(y)$$<br>对于连续随机变量，为<br>$$p(x)=\int p(x|y)p(y)dy$$  </p>
<h1 id="贝叶斯准则"><a href="#贝叶斯准则" class="headerlink" title="贝叶斯准则"></a>贝叶斯准则</h1><p>对于离散随机变量，为<br>$$p(x|y)=\frac{p(y|x)p(x)}{p(y)}=\frac{p(y|x)p(x)}{\sum_{x^\prime} p(y|x^\prime)p(x^\prime)}$$<br>对于连续随机变量，为<br>$$p(x|y)=\frac{p(y|x)p(x)}{p(y)}=\frac{p(y|x)p(x)}{\int p(y|x^\prime)p(x^\prime)dx^\prime}$$  </p>
<h2 id="条件概率下的贝叶斯准则"><a href="#条件概率下的贝叶斯准则" class="headerlink" title="条件概率下的贝叶斯准则"></a>条件概率下的贝叶斯准则</h2><p>给定条件随机变量$Z$取值为$Z=z$，则有<br>$$p(x|y,z)=\frac{p(y|x,z)p(x|z)}{p(y|z)}$$<br>其中$p(y|z)&gt;0$  </p>
<h1 id="条件独立"><a href="#条件独立" class="headerlink" title="条件独立"></a>条件独立</h1><p>如果对于给定条件$Z=z$的情况下，$X$和$Y$相互独立，则有<br>$$p(x,y|z)=p(x|z)p(y|z)$$<br>上式等效于<br>$$p(x|z)=p(x|z,y)$$<br>$$p(y|z)=p(y|z,x)$$  </p>
<p>注意：<br>$$p(x,y|z)=p(x|z)p(y|z)\nRightarrow p(x,y)=p(x)p(y)$$<br>$$p(x,y)=p(x)p(y)\nRightarrow p(x,y|z)=p(x|z)p(y|z)$$  </p>
<h1 id="期望和协方差"><a href="#期望和协方差" class="headerlink" title="期望和协方差"></a>期望和协方差</h1><h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><p>离散随机变量的情况下为<br>$$E[X]=\sum_x xp(x)$$<br>连续随机变量的情况下为<br>$$E[X]=\int xp(x)dx$$  </p>
<h2 id="期望的运算公式"><a href="#期望的运算公式" class="headerlink" title="期望的运算公式"></a>期望的运算公式</h2><p>线性特征<br>$$E[aX+b]=aE[X]+b$$</p>
<h2 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h2><p>$$Cov[X]=E[X-E[X]]^2=E[X^2]-E[X]^2$$  </p>
<h1 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h1><p>熵表示的是随机变量的不确定程度，定义为<br>$$H_p(x)=E[-log_2(x)]$$<br>离散随机变量的情况下计算公式为<br>$$H_p(x)=-\sum_x p(x)log_2p(x)$$<br>连续随机变量的情况下计算公式为<br>$$H_p(x)=-\int p(x)log_2(x)dx$$  </p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>Probabilitic Robotics</li>
</ul>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++二叉树可视化</title>
    <url>/2020/08/17/bintree_view/</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>C++程序中用到二叉树这种数据结构时，为了可以直观分析数据，好就是把二叉树进行可视化显示。不然调试程序的时候挺恼火的，某个二叉树变量需要一层一层展开分析，很不方便，于是想着写个可视化二叉树的工具。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>经过在网上查找一下，很多都是用到了<code>graphviz</code>来可视化， 也就是将二叉树转变为<code>dot</code>语言描述的图，然后利用<code>graphviz</code>库将其转为图片。于是本文针对<code>C/C++</code>中的二叉树，写一个自动可视化二叉树的工具。具体用到了两个第三方库：</p>
<ul>
<li><code>graphviz 2.40.1</code></li>
<li><code>OpenCV 2.3.0</code></li>
</ul>
<p><strong>具体思路是:</strong> 对二叉树进行层次遍历将二叉树转为<code>dot</code>，然后利用<code>graphviz</code>库对其进行布局和渲染，保存临时图片，最后利用<code>OpenCV</code>显示图片。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>基于上述描述，以下说明一下具体实现细节。首先是二叉树转<code>dot</code>：二叉树的一个基本结构是，一个节点指向左右节点，如图</p>
<p><img src="/2020/08/17/bintree_view/cell.png" alt="binary tree cell"></p>
<p>按这样，每遍历到一个节点的时候，则在<code>dot</code>中添加一个上述的基本结构，下图为一个小规模二叉树例子，如图</p>
<p><img src="/2020/08/17/bintree_view/without_placeholder.png" alt="binary tree example"></p>
<p>上图可以看到可视化出来并不是很美观，如图中节点<code>33</code>和<code>172</code>,直接由父节点垂直指出来，特别的，节点<code>172</code>无法判断是左节点还是有节点。于是，对二叉树可视化的基本结构进行了调整，如下图所示</p>
<p><img src="/2020/08/17/bintree_view/placeholder.png" alt="binary tree cell with placeholder"></p>
<p>即在父节点中间引出一个<code>placeholder</code>占位符，在生成的<code>dot</code>中设置占位符与父节点在同一个<code>group</code>，并且将占位符的节点和边设置属性为<code>style=invis</code>不可见状态。添加了占位符后，<code>dot</code>语言用法详见<a href="https://graphviz.gitlab.io/_pages/pdf/dotguide.pdf" target="_blank" rel="noopener">Drawing graphs with dot</a>,二叉树可视化结果如下图</p>
<p><img src="/2020/08/17/bintree_view/with_placeholder.png" alt="binary tree with placeholder"></p>
<p>上图程序生成的<code>dot</code>文本为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">digraph graphname &#123; </span><br><span class="line">    node [shape=box]; </span><br><span class="line">    edge [arrowhead=vee];</span><br><span class="line">    0 [label=&quot;0&quot;];</span><br><span class="line">    1 [label=&quot;149&quot; group=1];</span><br><span class="line">    0 -&gt; 1;</span><br><span class="line">    2 [label=&quot;&quot;, width=0.1, style=invis, group=0];</span><br><span class="line">    0 -&gt; 2 [style=invis];</span><br><span class="line">    3 [label=&quot;63&quot; group=3];</span><br><span class="line">    0 -&gt; 3;</span><br><span class="line">    4 [label=&quot;126&quot; group=4];</span><br><span class="line">    1 -&gt; 4;</span><br><span class="line">    5 [label=&quot;&quot;, width=0.1, style=invis, group=1];</span><br><span class="line">    1 -&gt; 5 [style=invis];</span><br><span class="line">    6 [label=&quot;20&quot; group=6];</span><br><span class="line">    1 -&gt; 6;</span><br><span class="line">    7 [label=&quot;&quot;, width=0.1, style=invis, group=3];</span><br><span class="line">    3 -&gt; 7 [style=invis];</span><br><span class="line">    8 [label=&quot;191&quot; group=8];</span><br><span class="line">    3 -&gt; 8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成了<code>dot</code>之后，其保存在一个字符串变量中，利用<code>graphviz</code>库对其进行渲染，如下代码所示，具体用法详见<a href="https://graphviz.gitlab.io/_pages/pdf/libguide.pdf" target="_blank" rel="noopener">Using Graphviz as a Library</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">graph_t</span> *g;</span><br><span class="line">GVC_t *gvc;</span><br><span class="line">gvc = gvContext();</span><br><span class="line">g = agmemread(dot_string);</span><br><span class="line"><span class="keyword">if</span>(g != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    gvLayout(gvc, g, <span class="string">"dot"</span>);</span><br><span class="line">    gvRenderFilename (gvc, g, <span class="string">"png"</span>, out_path);</span><br><span class="line">&#125;</span><br><span class="line">gvFreeLayout(gvc, g);</span><br><span class="line">agclose(g);</span><br><span class="line">gvFreeContext(gvc);</span><br></pre></td></tr></table></figure>

<h1 id="结果示例"><a href="#结果示例" class="headerlink" title="结果示例"></a>结果示例</h1><p>下面图是程序自动可视化二叉树的结果示例，包括了<code>highlight</code>指定节点的情况，程序源码详见<a href="https://github.com/hefvcjm/BinTreeView" target="_blank" rel="noopener">BinTreeView</a></p>
<p>无<code>highlight</code>示例：</p>
<p><img src="/2020/08/17/bintree_view/no_highlight.png" alt="binary tree visualization"></p>
<p>有<code>highlight</code>示例：</p>
<p><img src="/2020/08/17/bintree_view/highlight.png" alt="binary tree visualization with highlight nodes"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Binary Tree</tag>
        <tag>Visualization</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown基础语法学习</title>
    <url>/2019/07/07/markdown_learning/</url>
    <content><![CDATA[<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>进行简单的语法学习，先来个入门。</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><ul>
<li>这是第一项</li>
<li>这是第二项</li>
<li>这是第三项<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3></li>
</ul>
<ol>
<li>1 第一项</li>
<li>2 第二项</li>
<li>3 第三项</li>
</ol>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p><img src="/2019/07/07/markdown_learning/header.jpg" alt="测试图片"></p>
<h2 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h2><p><a href="header.jpg">测试链接</a></p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ul>
<li><strong>这是粗体</strong></li>
<li><em>这是斜体</em><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2></li>
</ul>
<table>
<thead>
<tr>
<th>表头</th>
<th>第一列</th>
<th>第二列</th>
<th>第三列</th>
</tr>
</thead>
<tbody><tr>
<td>第一行</td>
<td>11</td>
<td>12</td>
<td>13</td>
</tr>
<tr>
<td>第二行</td>
<td>21</td>
<td>22</td>
<td>23</td>
</tr>
<tr>
<td>第三行</td>
<td>31</td>
<td>32</td>
<td>33</td>
</tr>
</tbody></table>
<ul>
<li>:-表示左对齐</li>
<li>-:表示右对齐</li>
<li>:-:表示居中对齐</li>
<li>默认表头居中对齐，内容左对齐<h2 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">use <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argv, <span class="keyword">char</span>** argc)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><h3 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h3><p>这是一个行内公式：$ E=mc^2 $，哈哈</p>
<h3 id="行间公式"><a href="#行间公式" class="headerlink" title="行间公式"></a>行间公式</h3><p>上一行<br>$$ \sum_{i=1}^n a_i=0 $$<br>后一行</p>
<h2 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h2><p>三个*表示分隔符</p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>今天就学一下这些基本的啦~</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS源码学习move_base(1)——导航流程</title>
    <url>/2019/09/20/move_base_leaning_firework_1/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>move_base是一个开源2D移动机器人导航包，实现机器人自主导航到给定目标点的功能。move_base提供配置、运行以及跟<a href="http://wiki.ros.org/navigation" target="_blank" rel="noopener">导航栈</a>交互的接口，他的基本框架如下图所示，其核心包含了3大功能模块：<code>nav_core::BaseGlobalPlanner</code>，<code>nav_core::BaseLocalPlanner</code>和<code>nav_core::RecoveryBehavior</code>，他们以插件的形式加载到move_base中，分别实现全局路径规划、局部路径规划和恢复机制。</p>
<p><img src="/2019/09/20/move_base_leaning_firework_1/overview_tf_small.png" alt="move_base基本框架"></p>
<h1 id="源码流程整理"><a href="#源码流程整理" class="headerlink" title="源码流程整理"></a>源码流程整理</h1><p>move_base导航包就一个类，在move_base_node中初始化化节点后，实例化<code>move_base::MoveBase</code>类后，便进入导航流程。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化包括初始化类成员变量，从参数服务器中加载参数，启动线程planThread控制导航的主线，注册话题、服务、动态参数服务器，订阅话题以及加载全局路径规划、局部路径规划和恢复机制等模块。可以看到，在初始化后，程序在planThread线程中利用<code>planner_cond_.wait(lock)</code>进行阻塞，一直等待<code>planner_cond_.notify_one()</code>的唤醒。而唤醒主要发生在机器人接收到新目标调用<code>executeCb</code>函数中，在唤醒<code>planThread</code>的流程后，<code>executeCb</code>则开始执行导航控制流程<code>executeCycle</code>，在<code>executeCycle</code>中主要是利用状态机根据不同条件切换机器人当前状态，总共包括了3种状态：<code>PLANNING</code>、<code>CONTROLLING</code>和<code>CLEARING</code>，并且在相应的状态下执行相应的动作。</p>
<h2 id="planThread"><a href="#planThread" class="headerlink" title="planThread"></a>planThread</h2><p>当线程planThread的阻塞被唤醒后，开始进行全局规划路径，执行<code>makePlan</code>，如果成功规划出路径，则更新一些变量，同时将机器人状态切换至<code>CONTROLLING</code>；如果未能规划出全局路径，则循环进行重试，若重试至超时或者次数超出规定次数后，<code>planThread</code>则重新进入阻塞。直到定时器定时唤醒或者接收到新目标才又唤醒。<code>planThread</code>流程如下图所示。</p>
<p><img src="/2019/09/20/move_base_leaning_firework_1/planThread.png" alt="planThread运行流程"></p>
<h2 id="executeCB"><a href="#executeCB" class="headerlink" title="executeCB"></a>executeCB</h2><p><code>executeCB</code>是<code>move_base</code>接收到新目标时调用的函数，该函数主要实现的是执行<code>executeCycle</code>前的检测和完成一些变换，包括了多四元数的合法性判断、目标点向全局坐标系的转换以及<code>action</code>服务器目标抢占的判断和设置。对于抢占的理解参考<a href="http://www.itboth.com/d/I7Frue67FbEz" target="_blank" rel="noopener">这里</a>中的<code>7. 【SimpleActionServer Goal Policies】</code>，具体流程如下图所示。</p>
<p><img src="/2019/09/20/move_base_leaning_firework_1/executeCB.png" alt="executeCB运行流程"></p>
<h2 id="executeCycle"><a href="#executeCycle" class="headerlink" title="executeCycle"></a>executeCycle</h2><p><code>executeCycle</code>主要是开始对机器人进行控制，将全局路径设置到控制器，由局部路径规划器计算机器人的运动速度和方向，并发布<code>cmd_vel</code>话题。在这里也实现主要的状态机状态转换逻辑，控制流程如下图所示。</p>
<p><img src="/2019/09/20/move_base_leaning_firework_1/executeCycle.png" alt="executeCycle运行流程"></p>
<p><img src="/2019/09/20/move_base_leaning_firework_1/State_Machine.png" alt="状态机状态转换图"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>move_base将导航流程规范化并且进行了封装，将整过导航过程总结为全局路径规划、局部路径规划和恢复机制，并且以插件的方式加载这3个模块，在使用中我们可以基于move_base这个框架定制自己的全局路径规划器、局部路径规划器和恢复机制。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://wiki.ros.org/move_base" target="_blank" rel="noopener">wiki move_base</a></li>
<li><a href="http://www.itboth.com/d/I7Frue67FbEz" target="_blank" rel="noopener">ROS 进阶学习笔记（18）：ROS导航3：关于 ROS ActionLib 包</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/28386370" target="_blank" rel="noopener">知乎 ROS导航包源码学习7 — move_base</a></li>
<li><a href="https://www.cnblogs.com/shhu1993/p/6323699.html" target="_blank" rel="noopener">博客园 move_base代码学习一</a></li>
</ul>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>navigation</tag>
        <tag>move_base</tag>
      </tags>
  </entry>
  <entry>
    <title>说一下Python中的mixin模式</title>
    <url>/2020/09/23/python_mixin_design_pattern/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><code>mixin</code>是一种设计模式，实际上它类似于模板编程或者说接口编程，首先定义好一个算法或者某个任务流程的执行框架，然后把具体细节实现在<strong>基类</strong>中，像<code>C++</code>或<code>Java</code>则基本是将细节实现在派生类中。<code>mixin</code>的实现原理是，利用了<code>Python</code>的动态性，可以很方便地动态地改变类的继承关系，从而实现动态改变类的行为和属性。具体来说就是，通过修改某个类的<code>__bases__</code>属性（该属性不会出现在<code>__dict__</code>里面），实现了动态改变类的继承关系。  </p>
<h1 id="deallocator-differs问题"><a href="#deallocator-differs问题" class="headerlink" title="deallocator differs问题"></a>deallocator differs问题</h1><p>关于这个问题详细的讨论可以参考考<a href="https://bugs.python.org/issue672115" target="_blank" rel="noopener">Assignment to <strong>bases</strong> of direct object subclasses</a>，该问题讨论的版本是<code>Python 3.6</code>。在这里演示用的<code>Python2.7.12</code>版本中也是存在这个问题的，可以说一直到<code>Python 3.6</code>这个问题还依然存在。  </p>
<p>这个问题在这种情况下回发生，当一个类直接由内置对象<code>object</code>派生时，对该类的<code>__bases__</code>进行赋值操作时将会报错，如：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line">A.__bases__ = (B,)</span><br></pre></td></tr></table></figure>

<p>将会抛出一下异常信息：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TypeErrorTraceback (most recent call last)</span><br><span class="line">in ()</span><br><span class="line">1 class A(object): pass</span><br><span class="line">2 class B(object): pass</span><br><span class="line">----&gt; 3 A.__bases__ = (B,)</span><br><span class="line">TypeError: __bases__ assignment: &apos;B&apos; deallocator differs from &apos;object&apos;</span><br></pre></td></tr></table></figure>

<h1 id="mixin模式简单举例"><a href="#mixin模式简单举例" class="headerlink" title="mixin模式简单举例"></a>mixin模式简单举例</h1><p>按道理只要一个类不是直接继承自<code>object</code>（多继承这里就没去测试了），只要这种继承能够正常生成这个类的<code>MRO</code>列表，动态给这个类的<code>__bases__</code>赋值应该都会成功。下面举一个简单的例子说明<code>mixin</code>模式如何使用：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OBJ</span><span class="params">(object)</span>:</span><span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(OBJ)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">todo</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.set_value()</span><br><span class="line">        self.print_value()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_value</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"B set_value"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_value</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"C print_value"</span></span><br><span class="line">a = A()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"A __bases__:"</span>, A.__bases__</span><br><span class="line"><span class="keyword">print</span> <span class="string">"A MRO:"</span>, A.mro()</span><br><span class="line"><span class="comment"># a.todo() # 这里会出错error，找不到set_value函数</span></span><br><span class="line">A.__bases__ = (B, C)  <span class="comment"># 这里动态改变了A的父类，使得其拥有了set_value和print_value两个函数</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"A __bases__:"</span>, A.__bases__</span><br><span class="line"><span class="keyword">print</span> <span class="string">"A MRO:"</span>, A.mro()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"call todo:"</span></span><br><span class="line">a.todo()</span><br></pre></td></tr></table></figure>

<p>将会得到输出为：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A __bases__: (&lt;class &apos;__main__.OBJ&apos;&gt;,)</span><br><span class="line">A MRO: [&lt;class &apos;__main__.A&apos;&gt;, &lt;class &apos;__main__.OBJ&apos;&gt;, &lt;type &apos;object&apos;&gt;]</span><br><span class="line">A __bases__: (&lt;class &apos;__main__.B&apos;&gt;, &lt;class &apos;__main__.C&apos;&gt;)</span><br><span class="line">A MRO: [&lt;class &apos;__main__.A&apos;&gt;, &lt;class &apos;__main__.B&apos;&gt;, &lt;class &apos;__main__.C&apos;&gt;, &lt;type &apos;object&apos;&gt;]</span><br><span class="line">call todo:</span><br><span class="line">B set_value</span><br><span class="line">C print_value</span><br></pre></td></tr></table></figure>

<p>可以看到，A的继承关系被动态改变了，在todo函数中写好要执行的框架，然后框架中用到的函数操作留给了<strong>未来的父类去实现</strong>，同时也不用把所有的函数都在一个父类实现，不同的父类实现不同的功能，然后拼到一起。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>多继承</tag>
        <tag>mixin</tag>
      </tags>
  </entry>
  <entry>
    <title>pdb基本使用方法</title>
    <url>/2020/08/17/python_pdb_base/</url>
    <content><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>本文只要讲述一下<code>pdb</code>(The Python Debugger)的基本使用方法，<code>pdb</code>提供了强大、灵活的Python调试功能。之前我一直用的<code>Pycharm</code>或者<code>vscode</code>带的调试器，但在我使用过程中发现它们有时候会出现某些意想不到问题后（本来想调试自己代码的问题，调着调着就变成找调试器的bug了&gt;_&lt;）。</p>
<h2 id="Pycharm中的一个问题"><a href="#Pycharm中的一个问题" class="headerlink" title="Pycharm中的一个问题"></a>Pycharm中的一个问题</h2><p><strong>注:</strong>这里例子给的是<code>Pycharm 2019.2.1</code>这个版本的例子，不知道后面有没有更新解决  </p>
<p><img src="/2020/08/17/python_pdb_base/pycharm_debug_code.png" alt="python debug">  </p>
<p>如上面的工程，简单定义了两个文件，一个名为<code>threading.py</code>，里面啥也没有，一个就是<code>test.py</code>，代码就是图中简单的几行。设置断点开始调试，结果蹭蹭地弹出异常，如下图所示  </p>
<p><img src="/2020/08/17/python_pdb_base/pycharm_debug_exception.png" alt="python pydevd.py exception">  </p>
<p>呃呃，这个问题对于当时的我困扰许久，还以为<code>Pycharm</code>哪里没设置对，或者下载重装都没解决，后来大概看一下<code>pydevd.py</code>就发现问题。不过如果<code>import</code>的是内置的<code>threading</code>就不会出错，不过这种覆盖内置模块名字还是少干，容易出错，因为有时候你用的第三方库就依赖某个内置模块，而被你覆盖后就容易报错了。  </p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>上面的问题跑到<code>vscode</code>中就不存在，可以正常调试。另外在<code>vscode</code>和<code>Pycharm</code>中调试某些程序的时候（这里还没总结出简单的例子，不过本文不是这个重点所以大概提提），发现调试器一直无法获取程序上下文，简单说就是卡住了，看不到有啥变量以及变量的值是啥，这样的使得程序无法继续调试。最后，最最重要的是，当你只能在服务器或者只能远程连接都只能用终端操作的时候，这个时候就没辙了，乖乖的用起<code>pdb</code>来调试了。。  </p>
<h1 id="直奔主题——pdb基本使用"><a href="#直奔主题——pdb基本使用" class="headerlink" title="直奔主题——pdb基本使用"></a>直奔主题——pdb基本使用</h1><p>说了一堆屁话，该到本文主题了！<strong>这里示例是在<code>Python2.7</code>中演示。</strong></p>
<h2 id="要调试的程序"><a href="#要调试的程序" class="headerlink" title="要调试的程序"></a>要调试的程序</h2><p>这里是一段有bug的程序，如下所示  </p>
<pre><code class="Python"><span class="keyword">import</span> pdb
pdb.set_trace()

<span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(x, y)</span>:</span>
    a = <span class="number">0</span>
    b = <span class="number">1</span>
    result = <span class="number">0</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):
        result += x + y
    <span class="keyword">if</span> result &gt; <span class="number">100</span>:
        <span class="keyword">return</span> a
    <span class="keyword">else</span>:
        <span class="keyword">return</span> b


<span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(x)</span>:</span>
    result = <span class="number">0</span>
    result = func1(<span class="number">1</span>, <span class="number">2</span>)
    <span class="keyword">return</span> result + x


result = <span class="number">0</span>
result = func2(<span class="number">1</span>)
<span class="keyword">print</span> result</code></pre>
<p>连接到服务器，如下图所示：  </p>
<p><img src="/2020/08/17/python_pdb_base/code_pic.png" alt="代码片段">  </p>
<h2 id="进入调试状态"><a href="#进入调试状态" class="headerlink" title="进入调试状态"></a>进入调试状态</h2><p>即将开始调试了，首先是进入调试状态，有两种方法，一种是侵入式的调试方法，也就是和上图一样，<code>import pdb</code>然后在需要停下来的地方添加<code>pdb.set_trace()</code>，然后运行<code>Python</code>程序后就会在<code>pdb.set_trace()</code>后一句停下来。另一种则不用动源码，直接用<code>python -m pdb xxx.py</code>启动程序，就会进入调试状态。  </p>
<h2 id="常用调试命令"><a href="#常用调试命令" class="headerlink" title="常用调试命令"></a><span id="2.1"><a href="https://docs.python.org/2/library/pdb.html#debugger-commands" target="_blank" rel="noopener">常用调试命令</a></span></h2><p><strong>注：</strong>()表示可以省去，如<code>help</code>和<code>h</code>是一样的；[]表示选项，可以选择性输入。  </p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">h(elp)</td>
<td align="left">[command]</td>
<td align="left">获取命令帮助，没有参数的话则会输出全部调试命令</td>
</tr>
<tr>
<td align="center">w(here)</td>
<td align="left">-</td>
<td align="left">输出当前所在栈帧，<code>&gt;</code>表示当前所在的栈帧，<code>-&gt;</code>表示在每个栈帧中执行到的语句</td>
</tr>
<tr>
<td align="center">d(own)</td>
<td align="left">-</td>
<td align="left">移到下一个栈帧，即当前上下文为所到的栈帧</td>
</tr>
<tr>
<td align="center">u(p)</td>
<td align="left">-</td>
<td align="left">移到上一个栈帧，即当前上下文为所到的栈帧</td>
</tr>
<tr>
<td align="center">b(reak)</td>
<td align="left">[[filename:]lineno | function[, condition]]</td>
<td align="left">参数可以是`文件名:行号</td>
</tr>
<tr>
<td align="center">tbreak</td>
<td align="left">同b(reak)</td>
<td align="left">设置临时断点，参数同b(reak)，不同的是该断点进入一次后就被删除了</td>
</tr>
<tr>
<td align="center">cl(ear)</td>
<td align="left">[filename:lineno</td>
<td align="left">bpnumber [bpnumber …]]</td>
</tr>
<tr>
<td align="center">disable</td>
<td align="left">[bpnumber [bpnumber …]]</td>
<td align="left">禁止指定的多个断点，但不删除，需要的时候可以让其生效</td>
</tr>
<tr>
<td align="center">enable</td>
<td align="left">[bpnumber [bpnumber …]]</td>
<td align="left">让指定的几个断点重新生效</td>
</tr>
<tr>
<td align="center">ignore</td>
<td align="left">bpnumber [count]</td>
<td align="left">设置指定断点失效的次数，即在经过该断断点第<code>count+1</code>次的时候才会进入断点</td>
</tr>
<tr>
<td align="center">condition</td>
<td align="left">bpnumber [condition]</td>
<td align="left">和设置断点的时候一样，对某个断点设置生效的条件</td>
</tr>
<tr>
<td align="center">commands</td>
<td align="left">[bpnumber]</td>
<td align="left">可以在进入断点后执行一些命令集</td>
</tr>
<tr>
<td align="center">j(ump)</td>
<td align="left">lineno</td>
<td align="left">跳转到指定行，指定的行必须在</td>
</tr>
<tr>
<td align="center">l(ist)</td>
<td align="left">[first[, last]]</td>
<td align="left">列出从first到last之间的源代码，省略则列出当前执行点周围11行代码</td>
</tr>
<tr>
<td align="center">a(rgs)</td>
<td align="left">-</td>
<td align="left">打印当前执行函数的参数</td>
</tr>
<tr>
<td align="center">p</td>
<td align="left">expression</td>
<td align="left">执行一个python表达式</td>
</tr>
<tr>
<td align="center">[!]</td>
<td align="left">statement</td>
<td align="left">执行一行python语句</td>
</tr>
<tr>
<td align="center">run</td>
<td align="left">[args …]</td>
<td align="left">重启程序</td>
</tr>
<tr>
<td align="center">q(uit)</td>
<td align="left">-</td>
<td align="left">退出调试器</td>
</tr>
</tbody></table>
<h2 id="几个命令说明"><a href="#几个命令说明" class="headerlink" title="几个命令说明"></a>几个命令说明</h2><p>在上面<a href="#2.1">常用的命令</a>中，其中<code>b(reak)</code>,<code>c(ontinue)</code>,<code>s(tep)</code>,<code>n(ext)</code>,<code>r(eturn)</code>,<code>l(ist)</code>,<code>w(here)</code>这几个命令是更加常用的。  </p>
<p>具体用法如上面表中所说那样，主要是要区分以下<code>c(ontinue)</code>,<code>s(tep)</code>,<code>n(ext)</code>的区别  </p>
<ul>
<li><code>c(ontinue)</code>表示继续执行，知道遇到下一个断点，如果没有了断点则自动重新启动程序；</li>
<li><code>s(tep)</code>表示单步执行，一步一步走，遇到函数则进入函数继续一步步执行；</li>
<li><code>n(ext)</code>表示在当前栈帧中一步步执行，遇到函数不会进去，而是当成一句直接执行再到下一句。</li>
<li><code>r(eturn)</code>表示返回，直接跳到栈帧的最后一句（不是位置上的最后，而是执行中可达的最后），相当于如果是在函数中则直接调到函数返回的地方。  </li>
</ul>
<p>另外就是<code>b(reak)</code>加上条件，或者用<code>condition</code>给断点加个条件，在调试中有时候也很有用，比如说上面的代码在循环中，循环99次出现bug，要看看循环到100次的时候哪里出bug。在用IDE调试的时候我没找到什么好的方法，只能在源码中添加个<code>if</code>语句再循环99次的时候进入，然后就在<code>if</code>里面打断点。但是用<code>pdb</code>就可以给断点加个条件，当满足条件的时候才进入断点，上面的例子就可以设置断点为：  </p>
<pre><code class="shell">(Pdb) b 10,i==99</code></pre>
<p>这样的话就可以在进入断点前就循环了99次了，很是方便。当然也可以给已经打了的断点添加条件，利用的就是<code>condition</code>命令，比如说打在第10行的断点的断点号是1，那么就可以：  </p>
<pre><code class="shell">(Pdb) condition 1 i==99</code></pre>
<p>这样同样能达到上面的效果。  </p>
<p>然后就是清除某个断点的条件了，具体的就是再执行以下<code>condition</code>命令，只是没写条件就ok了。  </p>
<p>最后，要了解更多的命令细节，在实践中操作很容易掌握，凡事还是多动手才能熟练起来。  </p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Debug</tag>
        <tag>pdb</tag>
      </tags>
  </entry>
  <entry>
    <title>射线投射(Ray Cast)生成虚拟激光数据</title>
    <url>/2019/09/25/ray_caster_visual_laser/</url>
    <content><![CDATA[<h1 id="map-scan"><a href="#map-scan" class="headerlink" title="map_scan"></a>map_scan</h1><p>Using ray-cast to generate virtual LaserScan data in given map, only work for 2D mobile robot. Refer to the <a href="https://github.com/hefvcjm/map_scan.git" target="_blank" rel="noopener">source</a>.</p>
<h1 id="Instructions"><a href="#Instructions" class="headerlink" title="Instructions"></a>Instructions</h1><p>map_scan is a ros package which implements <code>ray-cast</code> to generate virtual <code>LaserScan</code> data in given map. It’s very appriciated that the <a href="https://github.com/ros-planning/navigation.git" target="_blank" rel="noopener">amcl</a> had implemented the beam ray-cast wonderfully. And in this package, it will use the beam ray-cast provided by amcl and just modify it a little.</p>
<h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><p><strong>Note:</strong> To use this package, you could pull down the code to your computer. However, I should tell you that the package only has been tested in Ubuntu 16.04 and Ubuntu 18.04 corresponding to <code>ROS</code> distribution of <code>kinetic</code> and <code>melodic</code>.</p>
<h2 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h2><p>New a folder as your workspace. Below is the example.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> mkdir -p ~/raycaster/src</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> ~/raycaster/src</span></span><br></pre></td></tr></table></figure>

<h2 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h2><p>Pull down the code to your workspace.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/hefvcjm/map_scan.git</span></span><br></pre></td></tr></table></figure>

<h2 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h2><p>Compile the code.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> ~/raycaster</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> catkin_make</span></span><br></pre></td></tr></table></figure>

<h2 id="Step-4"><a href="#Step-4" class="headerlink" title="Step 4"></a>Step 4</h2><p>If you have sussecced to compile the code. Congratulations. And you can run the test code to feel how it works.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">source</span> devel/setup.bash</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> roslaunch map_scan test.launch</span></span><br></pre></td></tr></table></figure>

<p>And you can see something like below.<br><img src="https://github.com/hefvcjm/map_scan/raw/master/screenshot/virtual_scan_test.png" alt="screenshot"><br>The arrow is the virtual-laser pose. And the green bound is the visualization of the LaserScan data.</p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="Services-Called"><a href="#Services-Called" class="headerlink" title="Services Called"></a>Services Called</h2><p>static_map (<a href="http://docs.ros.org/api/nav_msgs/html/srv/GetMap.html" target="_blank" rel="noopener">nav_msgs/GetMap</a>)<br>map_scan calls this service to retrieve the map that is used for virtual-laser-based localization; startup blocks on getting the map from this service.</p>
<h2 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h2><p>map_scan(<a href="https://github.com/hefvcjm/map_scan/blob/master/srv/GetMapScan.srv" target="_blank" rel="noopener">map_scan/GetMapScan</a>)<br>Service to get the virtual-laser-scan in the map given the pose and the info of the virtual-laser. </p>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>Ray Cast</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow中的constant，Variable，placeholder</title>
    <url>/2019/10/03/tensorflow_basic/</url>
    <content><![CDATA[<h1 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h1><p>介绍TensorFlow中常量(constant)、变量(Variable)和占位符(placeholder)的用法。</p>
<h1 id="tf-constant"><a href="#tf-constant" class="headerlink" title="tf.constant"></a>tf.constant</h1><p>创建TensorFlow常量。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.constant(</span><br><span class="line">    value,</span><br><span class="line">    dtype=<span class="literal">None</span>,</span><br><span class="line">    shape=<span class="literal">None</span>,</span><br><span class="line">    name=<span class="string">'Const'</span>,</span><br><span class="line">    verify_shape=<span class="literal">False</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>其中value时TensorFlow常量存储的值，dtype是value元素的类型，shape为该常量的形状，name是该常量的别名，verify_shape为布尔型表示是否验证形状。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>例子1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">a = tf.constant(<span class="number">2.0</span>)</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    print(sess.run(a))</span><br><span class="line"><span class="comment">#output: </span></span><br><span class="line"><span class="comment">#2.0</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">例子<span class="number">2</span></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">a = tf.constant(<span class="number">2.0</span>)</span><br><span class="line">b = tf.constant(<span class="number">5.0</span>)</span><br><span class="line">c = tf.add(a, b)</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    print(sess.run(c))</span><br><span class="line"><span class="comment">#output: </span></span><br><span class="line"><span class="comment">#7.0</span></span><br></pre></td></tr></table></figure>

<h1 id="tf-Variable"><a href="#tf-Variable" class="headerlink" title="tf.Variable"></a>tf.Variable</h1><p>创建TensorFlow变量，可以用变量来存储和更新训练模型时的参数。变量包含张量(Tensor)存放于内存的缓冲区。建立时需要对它们进行明确的初始化，模型训练完后它们也必须被存储到磁盘中。</p>
<h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.Variable(</span><br><span class="line">    initial_value, </span><br><span class="line">    name=<span class="string">'Variable'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>详细说明参见<a href="https://www.tensorflow.org/api_docs/python/tf/Variable#__init__" target="_blank" rel="noopener">官网API文档</a></p>
<h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><p>例子1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">a = tf.Variable(<span class="number">3.0</span>)</span><br><span class="line">init = tf.variables_initializer([a])</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    print(sess.run(a))</span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"><span class="comment">#3.0</span></span><br></pre></td></tr></table></figure>

<p>变量定义后需要初始化才能使用。  </p>
<p>例子2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">a = tf.Variable([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">init = tf.variables_initializer([a])</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    print(sess.run(a))</span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"><span class="comment">#[1 2 3 4 5 6]</span></span><br><span class="line">update = tf.assign(a,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(update)</span><br><span class="line">    print(sess.run(a))</span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"><span class="comment">#[2 3 4 5 6 7]</span></span><br></pre></td></tr></table></figure>

<p>这里演示的是如何更新TensorFlow变量的值，需要使用tf.assign函数。</p>
<h1 id="tf-placeholder"><a href="#tf-placeholder" class="headerlink" title="tf.placeholder"></a>tf.placeholder</h1><p>创建TensorFlow占位符。</p>
<h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.placeholder(</span><br><span class="line">    dtype,</span><br><span class="line">    shape=<span class="literal">None</span>,</span><br><span class="line">    name=<span class="literal">None</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>其中dtype是占位符值元素的类型，shape为占位符形状，name为别名。</p>
<h2 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = tf.placeholder(tf.float32, shape=(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">b = tf.placeholder(tf.float32, shape=(<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line">y = tf.matmul(a, b)</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    print(sess.run(y, feed_dict=&#123;a:[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]], b:[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>]]&#125;))</span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"><span class="comment">#[[14. 20.]</span></span><br><span class="line"><span class="comment"># [26. 38.]]</span></span><br></pre></td></tr></table></figure>

<p>存在占位符的操作在sess.run的时候需要“喂数据”才能正确的完成操作运算。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>constant、Variable和placeholder是TensorFlow中的数据类型，它们都属于张量(Tensor)数据类型。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.tensorflow.org/api_docs/python/tf/constant" target="_blank" rel="noopener">TensorFlow API</a></li>
<li><a href="http://tensorfly.cn/tfdoc/how_tos/variables.html" target="_blank" rel="noopener">变量:创建、初始化、保存和加载</a></li>
<li><a href="https://github.com/machinelearningmindset/TensorFlow-Course" target="_blank" rel="noopener">TensorFlow-Course</a></li>
</ul>
]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title>AMCL源码阅读(1)——程序流程</title>
    <url>/2019/08/16/amcl_program_flow/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>阅读AMCL源码，首先撇开算法具体细节以及技术细节，对ACML核心程序流程进行整理，看懂AMCL由外部数据触发到完成定位的整个过程。这里读的是<a href="https://github.com/ros-planning/navigation.git" target="_blank" rel="noopener">navigation仓库</a>melodic-devel分支，提交<code>id</code>为<code>b52e0ea9362131dc81326da471792ab8698c9564</code>的源码。</p>
<h1 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h1><p>先找到程序入口，也就是<code>main</code>函数，可以直接搜索<code>main</code>就可以很快定位到该函数了，主函数很短，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span><br><span class="line">&#123;</span><br><span class="line">  ros::init(argc, argv, <span class="string">"amcl"</span>);</span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Override default sigint handler</span></span><br><span class="line">  signal(SIGINT, sigintHandler);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make our node available to sigintHandler</span></span><br><span class="line">  amcl_node_ptr.reset(<span class="keyword">new</span> AmclNode());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc == <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// run using ROS input</span></span><br><span class="line">    ros::spin();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((argc == <span class="number">3</span>) &amp;&amp; (<span class="built_in">std</span>::<span class="built_in">string</span>(argv[<span class="number">1</span>]) == <span class="string">"--run-from-bag"</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    amcl_node_ptr-&gt;runFromBag(argv[<span class="number">2</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Without this, our boost locks are not shut down nicely</span></span><br><span class="line">  amcl_node_ptr.reset();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// To quote Morgan, Hooray!</span></span><br><span class="line">  <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，主函数中简单的初始化一下节点，初始化<code>AmclNode</code>类，然后根据命令参数的个数<code>argc</code>分别有两种执行方式，一种是直接接受传感器数据运行，一种是利用<code>bag</code>文件回放数据运行。我们跳到<code>runFromBag</code>函数中，可以看到利用<code>bag</code>文件数据文件运行的方式大概就是回放<code>bag</code>文件中的话题数据，不断读取并发布。所以，核心的流程还是一致的。</p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>在主函数中可以看到，那里直接实例化<code>AmclNode</code>类后就进入<code>ros::spin();</code>。因此，从<code>AmclNode</code>构造函数开始看，可以看到，在构造函数中，<code>AmclNode</code>对很对成员变量进行初始化以及从参数服务器读取各个配置参数，然后注册几个话题的发布和订阅以及一些服务，大致就完成了。所以初始化完成之后，主要入口就是几个话题和服务了。  </p>
<p>这里为了把握住主线，我们还是得找出核心的东西来，首先服务和发布的话题先不管，因为服务相对还是比较“被动”地调用，而发布的话题，则是对外的，也先不管。因此，就主要关注一下订阅的几个话题了，包括<code>scan</code>，<code>initialpose</code>和<code>map</code>。其实还有<code>tf</code>，不过<code>tf</code>主要就是读一下一些变化或者发布一下，主要在代码执行过程中需要的时候查询一下获取信息就完事了。</p>
<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>经过上面的整理，我们的重点就落在了几个订阅话题的回调函数中了，也不多，也就仨。一看就可以看出来哪个是重头戏了，<code>initialpose</code>和<code>map</code>话题回调函数中其实还是设置算法参数，分别设置初始化姿态和栅格地图。到这里，核心的部分也就出来了，就是订阅雷达话题<code>scan</code>的回调函数<code>laserReceived</code>,这里将这段代码贴出来，在注释中说明到底干了啥！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">AmclNode::laserReceived(<span class="keyword">const</span> sensor_msgs::LaserScanConstPtr&amp; laser_scan)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 首先获取当前激光雷达的frame_id</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> laser_scan_frame_id = stripSlash(laser_scan-&gt;header.frame_id);</span><br><span class="line">  <span class="comment">// 记录当前时间</span></span><br><span class="line">  last_laser_received_ts_ = ros::Time::now();</span><br><span class="line">  <span class="keyword">if</span>( map_ == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  boost::recursive_mutex::<span class="function">scoped_lock <span class="title">lr</span><span class="params">(configuration_mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> laser_index = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do we have the base-&gt;base_laser Tx yet?</span></span><br><span class="line">  <span class="comment">// 查询一下该雷达之前是不是有记录过，否则说明就是新的雷达，也就是第一次收到该雷达数据</span></span><br><span class="line">  <span class="keyword">if</span>(frame_to_laser_.find(laser_scan_frame_id) == frame_to_laser_.end())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 如果当真是新的雷达，则进入到这里</span></span><br><span class="line">    ROS_DEBUG(<span class="string">"Setting up laser %d (frame_id=%s)\n"</span>, (<span class="keyword">int</span>)frame_to_laser_.size(), laser_scan_frame_id.c_str());</span><br><span class="line">    <span class="comment">// 将雷达先用自定义的类封装一下并且保存到雷达列表，并且设置对应的更新标记，和在雷达列表中的索引，后面要用到</span></span><br><span class="line">    lasers_.push_back(<span class="keyword">new</span> AMCLLaser(*laser_));</span><br><span class="line">    lasers_update_.push_back(<span class="literal">true</span>);</span><br><span class="line">    laser_index = frame_to_laser_.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来主要就是通过tf查询该雷达与base_frame之间的转换，即雷达相对于base_link的位姿</span></span><br><span class="line">    geometry_msgs::PoseStamped ident;</span><br><span class="line">    ident.header.frame_id = laser_scan_frame_id;</span><br><span class="line">    ident.header.stamp = ros::Time();</span><br><span class="line">    tf2::toMsg(tf2::Transform::getIdentity(), ident.pose);</span><br><span class="line"></span><br><span class="line">    geometry_msgs::PoseStamped laser_pose;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;tf_-&gt;transform(ident, laser_pose, base_frame_id_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(tf2::TransformException&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">      ROS_ERROR(<span class="string">"Couldn't transform from %s to %s, "</span></span><br><span class="line">                <span class="string">"even though the message notifier is in use"</span>,</span><br><span class="line">                laser_scan_frame_id.c_str(),</span><br><span class="line">                base_frame_id_.c_str());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pf_vector_t</span> laser_pose_v;</span><br><span class="line">    laser_pose_v.v[<span class="number">0</span>] = laser_pose.pose.position.x;</span><br><span class="line">    laser_pose_v.v[<span class="number">1</span>] = laser_pose.pose.position.y;</span><br><span class="line">    <span class="comment">// laser mounting angle gets computed later -&gt; set to 0 here!</span></span><br><span class="line">    laser_pose_v.v[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 到这里查询完了该雷达相对于base_link的位姿了，就调用自定义封装激光的类进行设置这个参数，也就是保存下来</span></span><br><span class="line">    lasers_[laser_index]-&gt;SetLaserPose(laser_pose_v);</span><br><span class="line">    ROS_DEBUG(<span class="string">"Received laser's pose wrt robot: %.3f %.3f %.3f"</span>,</span><br><span class="line">              laser_pose_v.v[<span class="number">0</span>],</span><br><span class="line">              laser_pose_v.v[<span class="number">1</span>],</span><br><span class="line">              laser_pose_v.v[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">// 最后添加key-value到一个map中，该map作用是利用雷达的frame_id查询该雷达在列表中的索引，</span></span><br><span class="line">    <span class="comment">// 也就是key为雷达的frame_id，value为雷达在列表中的索引</span></span><br><span class="line">    frame_to_laser_[laser_scan_frame_id] = laser_index;</span><br><span class="line">    <span class="comment">// 到这里完成了保存新的雷达信息了</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果该雷达在记录中存在，那么就获取该雷达索引</span></span><br><span class="line">    <span class="comment">// we have the laser pose, retrieve laser index</span></span><br><span class="line">    laser_index = frame_to_laser_[laser_scan_frame_id];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Where was the robot when this scan was taken?</span></span><br><span class="line">  <span class="comment">// 获取当前机器人位姿</span></span><br><span class="line">  <span class="keyword">pf_vector_t</span> pose;</span><br><span class="line">  <span class="keyword">if</span>(!getOdomPose(latest_odom_pose_, pose.v[<span class="number">0</span>], pose.v[<span class="number">1</span>], pose.v[<span class="number">2</span>],</span><br><span class="line">                  laser_scan-&gt;header.stamp, base_frame_id_))</span><br><span class="line">  &#123;</span><br><span class="line">    ROS_ERROR(<span class="string">"Couldn't determine robot's pose associated with laser scan"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">pf_vector_t</span> delta = pf_vector_zero();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下来这部分就是根据是否已经初始化粒子滤波来设置每个雷达是否需要更新的标记</span></span><br><span class="line">  <span class="keyword">if</span>(pf_init_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 如果已经初始化粒子滤波器</span></span><br><span class="line">    <span class="comment">// Compute change in pose</span></span><br><span class="line">    <span class="comment">//delta = pf_vector_coord_sub(pose, pf_odom_pose_);</span></span><br><span class="line">    delta.v[<span class="number">0</span>] = pose.v[<span class="number">0</span>] - pf_odom_pose_.v[<span class="number">0</span>];</span><br><span class="line">    delta.v[<span class="number">1</span>] = pose.v[<span class="number">1</span>] - pf_odom_pose_.v[<span class="number">1</span>];</span><br><span class="line">    delta.v[<span class="number">2</span>] = angle_diff(pose.v[<span class="number">2</span>], pf_odom_pose_.v[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See if we should update the filter</span></span><br><span class="line">    <span class="keyword">bool</span> update = <span class="built_in">fabs</span>(delta.v[<span class="number">0</span>]) &gt; d_thresh_ ||</span><br><span class="line">                  <span class="built_in">fabs</span>(delta.v[<span class="number">1</span>]) &gt; d_thresh_ ||</span><br><span class="line">                  <span class="built_in">fabs</span>(delta.v[<span class="number">2</span>]) &gt; a_thresh_;</span><br><span class="line">    update = update || m_force_update;</span><br><span class="line">    m_force_update=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the laser update flags</span></span><br><span class="line">    <span class="comment">// 在上面计算后，在两种情况下全部雷达需要设置更新标记</span></span><br><span class="line">    <span class="comment">// 一种是机器人运动运动距离超过设定的距离</span></span><br><span class="line">    <span class="comment">// 一种是设置了没有运动也强制更新</span></span><br><span class="line">    <span class="keyword">if</span>(update)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; lasers_update_.size(); i++)</span><br><span class="line">        lasers_update_[i] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> force_publication = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(!pf_init_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 如果没有初始化粒子滤波器</span></span><br><span class="line">    <span class="comment">// Pose at last filter update</span></span><br><span class="line">    pf_odom_pose_ = pose;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这里可以看到只有这个地方设置了pf_init_ = true</span></span><br><span class="line">    <span class="comment">// 也就是说该标记为只有在第一次收到雷达数据后才设置为true</span></span><br><span class="line">    <span class="comment">// 即第一次接收到雷达数据进入的是这里</span></span><br><span class="line">    <span class="comment">// 后面的在没有异常（重新加载地图、重新发布初始化位姿等等）的情况下将都不会进入这里</span></span><br><span class="line">    <span class="comment">// Filter is now initialized</span></span><br><span class="line">    pf_init_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里说明在第一次收到雷达数据的时候默认要全部更新</span></span><br><span class="line">    <span class="comment">// Should update sensor data</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; lasers_update_.size(); i++)</span><br><span class="line">      lasers_update_[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    force_publication = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    resample_count_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If the robot has moved, update the filter</span></span><br><span class="line">  <span class="comment">// 如果粒子滤波器已经初始化，并且当前雷达标记为需要更新，则进入下面的代码块</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pf_init_ &amp;&amp; lasers_update_[laser_index])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 这里面可以看到的是，利用UpdateAction更新粒子滤波器，确切的说就是用里程计预测位姿</span></span><br><span class="line">    <span class="comment">//printf("pose\n");</span></span><br><span class="line">    <span class="comment">//pf_vector_fprintf(pose, stdout, "%.3f");</span></span><br><span class="line"></span><br><span class="line">    AMCLOdomData odata;</span><br><span class="line">    odata.pose = pose;</span><br><span class="line">    <span class="comment">// HACK</span></span><br><span class="line">    <span class="comment">// Modify the delta in the action data so the filter gets</span></span><br><span class="line">    <span class="comment">// updated correctly</span></span><br><span class="line">    odata.delta = delta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the action data to update the filter</span></span><br><span class="line">    odom_-&gt;UpdateAction(pf_, (AMCLSensorData*)&amp;odata);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pose at last filter update</span></span><br><span class="line">    <span class="comment">//this-&gt;pf_odom_pose = pose;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> resampled = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// If the robot has moved, update the filter</span></span><br><span class="line">  <span class="comment">// 如果当前雷达标记了更新，下面步骤就是进行更新步骤，也就是利用雷达数据更细粒子的权重</span></span><br><span class="line">  <span class="keyword">if</span>(lasers_update_[laser_index])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 下面一大段大概时获取当前雷达的一个AMCLLaserData对象</span></span><br><span class="line">    <span class="comment">// 包括各种转换和判断等等</span></span><br><span class="line">    AMCLLaserData ldata;</span><br><span class="line">    ldata.sensor = lasers_[laser_index];</span><br><span class="line">    ldata.range_count = laser_scan-&gt;ranges.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// To account for lasers that are mounted upside-down, we determine the</span></span><br><span class="line">    <span class="comment">// min, max, and increment angles of the laser in the base frame.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Construct min and max angles of laser, in the base_link frame.</span></span><br><span class="line">    tf2::Quaternion q;</span><br><span class="line">    q.setRPY(<span class="number">0.0</span>, <span class="number">0.0</span>, laser_scan-&gt;angle_min);</span><br><span class="line">    geometry_msgs::QuaternionStamped min_q, inc_q;</span><br><span class="line">    min_q.header.stamp = laser_scan-&gt;header.stamp;</span><br><span class="line">    min_q.header.frame_id = stripSlash(laser_scan-&gt;header.frame_id);</span><br><span class="line">    tf2::convert(q, min_q.quaternion);</span><br><span class="line"></span><br><span class="line">    q.setRPY(<span class="number">0.0</span>, <span class="number">0.0</span>, laser_scan-&gt;angle_min + laser_scan-&gt;angle_increment);</span><br><span class="line">    inc_q.header = min_q.header;</span><br><span class="line">    tf2::convert(q, inc_q.quaternion);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      tf_-&gt;transform(min_q, min_q, base_frame_id_);</span><br><span class="line">      tf_-&gt;transform(inc_q, inc_q, base_frame_id_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(tf2::TransformException&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">      ROS_WARN(<span class="string">"Unable to transform min/max laser angles into base frame: %s"</span>,</span><br><span class="line">               e.what());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> angle_min = tf2::getYaw(min_q.quaternion);</span><br><span class="line">    <span class="keyword">double</span> angle_increment = tf2::getYaw(inc_q.quaternion) - angle_min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wrapping angle to [-pi .. pi]</span></span><br><span class="line">    angle_increment = <span class="built_in">fmod</span>(angle_increment + <span class="number">5</span>*M_PI, <span class="number">2</span>*M_PI) - M_PI;</span><br><span class="line"></span><br><span class="line">    ROS_DEBUG(<span class="string">"Laser %d angles in base frame: min: %.3f inc: %.3f"</span>, laser_index, angle_min, angle_increment);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply range min/max thresholds, if the user supplied them</span></span><br><span class="line">    <span class="keyword">if</span>(laser_max_range_ &gt; <span class="number">0.0</span>)</span><br><span class="line">      ldata.range_max = <span class="built_in">std</span>::min(laser_scan-&gt;range_max, (<span class="keyword">float</span>)laser_max_range_);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ldata.range_max = laser_scan-&gt;range_max;</span><br><span class="line">    <span class="keyword">double</span> range_min;</span><br><span class="line">    <span class="keyword">if</span>(laser_min_range_ &gt; <span class="number">0.0</span>)</span><br><span class="line">      range_min = <span class="built_in">std</span>::max(laser_scan-&gt;range_min, (<span class="keyword">float</span>)laser_min_range_);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      range_min = laser_scan-&gt;range_min;</span><br><span class="line">    <span class="comment">// The AMCLLaserData destructor will free this memory</span></span><br><span class="line">    ldata.ranges = <span class="keyword">new</span> <span class="keyword">double</span>[ldata.range_count][<span class="number">2</span>];</span><br><span class="line">    ROS_ASSERT(ldata.ranges);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ldata.range_count;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// amcl doesn't (yet) have a concept of min range.  So we'll map short</span></span><br><span class="line">      <span class="comment">// readings to max range.</span></span><br><span class="line">      <span class="keyword">if</span>(laser_scan-&gt;ranges[i] &lt;= range_min)</span><br><span class="line">        ldata.ranges[i][<span class="number">0</span>] = ldata.range_max;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ldata.ranges[i][<span class="number">0</span>] = laser_scan-&gt;ranges[i];</span><br><span class="line">      <span class="comment">// Compute bearing</span></span><br><span class="line">      ldata.ranges[i][<span class="number">1</span>] = angle_min +</span><br><span class="line">              (i * angle_increment);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这里算是已经获得了当前雷达的AMCLLaserData对象了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后利用UpdateSensor进行更新粒子权重</span></span><br><span class="line">    lasers_[laser_index]-&gt;UpdateSensor(pf_, (AMCLSensorData*)&amp;ldata);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新了权重之后，重新清空了当前雷达的更新标记</span></span><br><span class="line">    lasers_update_[laser_index] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    pf_odom_pose_ = pose;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Resample the particles</span></span><br><span class="line">    <span class="comment">// 完成了预测和更新后，就开始重要性采样了</span></span><br><span class="line">    <span class="comment">// 这里设置了重要性采样的周期，也就是每接收几次雷达数据采样一次</span></span><br><span class="line">    <span class="keyword">if</span>(!(++resample_count_ % resample_interval_))</span><br><span class="line">    &#123;</span><br><span class="line">      pf_update_resample(pf_);</span><br><span class="line">      <span class="comment">// 采样完后设置一下说明已经采样的标记</span></span><br><span class="line">      resampled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里粒子滤波的基本过程已经完成了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pf_sample_set_t</span>* <span class="built_in">set</span> = pf_-&gt;sets + pf_-&gt;current_set;</span><br><span class="line">    ROS_DEBUG(<span class="string">"Num samples: %d\n"</span>, <span class="built_in">set</span>-&gt;sample_count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Publish the resulting cloud</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> set maximum rate for publishing</span></span><br><span class="line">    <span class="comment">// 这里就开始发布当前的全部粒子位姿</span></span><br><span class="line">    <span class="keyword">if</span> (!m_force_update)</span><br><span class="line">    &#123;</span><br><span class="line">      geometry_msgs::PoseArray cloud_msg;</span><br><span class="line">      cloud_msg.header.stamp = ros::Time::now();</span><br><span class="line">      cloud_msg.header.frame_id = global_frame_id_;</span><br><span class="line">      cloud_msg.poses.resize(<span class="built_in">set</span>-&gt;sample_count);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">set</span>-&gt;sample_count;i++)</span><br><span class="line">      &#123;</span><br><span class="line">        cloud_msg.poses[i].position.x = <span class="built_in">set</span>-&gt;samples[i].pose.v[<span class="number">0</span>];</span><br><span class="line">        cloud_msg.poses[i].position.y = <span class="built_in">set</span>-&gt;samples[i].pose.v[<span class="number">1</span>];</span><br><span class="line">        cloud_msg.poses[i].position.z = <span class="number">0</span>;</span><br><span class="line">        tf2::Quaternion q;</span><br><span class="line">        q.setRPY(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">set</span>-&gt;samples[i].pose.v[<span class="number">2</span>]);</span><br><span class="line">        tf2::convert(q, cloud_msg.poses[i].orientation);</span><br><span class="line">      &#125;</span><br><span class="line">      particlecloud_pub_.publish(cloud_msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果已经采样，或者强制发布当前机器人位姿，则进入下面流程</span></span><br><span class="line">  <span class="comment">// 最后这里主要就是根据例子加权估计当前位姿并发布，以及发布一下odom到map的变换关系</span></span><br><span class="line">  <span class="keyword">if</span>(resampled || force_publication)</span><br><span class="line">  &#123;</span><br><span class="line">    ... <span class="comment">// 这里省略若干行</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(latest_tf_valid_)</span><br><span class="line">  &#123;</span><br><span class="line">    ... <span class="comment">// 这里省略若干行</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  diagnosic_updater_.update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是Amcl执行的核心流程，可以说思路是很明确的，在各种情况判断后，依次进行<code>odom_-&gt;UpdateAction(pf_, (AMCLSensorData*)&amp;odata);</code>，<code>lasers_[laser_index]-&gt;UpdateSensor(pf_, (AMCLSensorData*)&amp;ldata);</code>和<code>pf_update_resample(pf_);</code>，这三步就是粒子滤波三个核心步骤的接口，分别实现预测、更新和重要性采样算法。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://wiki.ros.org/amcl" target="_blank" rel="noopener">wiki ROS Amcl</a></li>
</ul>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>navigation</tag>
        <tag>AMCL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python修饰器(Decorator)备忘</title>
    <url>/2019/11/15/python_decorator_note/</url>
    <content><![CDATA[<h1 id="什么是Python修饰器"><a href="#什么是Python修饰器" class="headerlink" title="什么是Python修饰器"></a>什么是Python修饰器</h1><p>修饰器是Python语言的一种重要特性，简单说它是一种能够修改其他函数功能的函数。熟练的使用可以是我们的代码更加简洁和更加<code>Pythonic</code>。刚开始接触会觉得有点绕，但是理解了之后就显得很常规了。</p>
<h1 id="闭包-Closure"><a href="#闭包-Closure" class="headerlink" title="闭包(Closure)"></a>闭包(Closure)</h1><p>要谈修饰器，首先得提一下闭包。闭包也算是一种挺有用也比较神奇的语言特性，那什么是闭包呢？闭包其实是一种函数对象，它能够记住某个封闭作用域的变量，即便该变量已经不在内存中了。这听着就很神奇了。下面看个例子吧！  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">()</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increase</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> i</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> increase</span><br><span class="line"></span><br><span class="line">my_counter = counter()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    print(my_counter(), end=<span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># 1 2 3 4 5 6 7 8 9 10</span></span><br></pre></td></tr></table></figure>

<p>上面的程序看起来还是比较普通的，但是我们分析一下，就发现很有意思的了。程序实现的是计数功能，我们定义了一个<code>counter</code>函数，里面嵌套了一个<code>increase</code>函数并且用到了外层函数的局部变量，执行自增1的操作并返回，大致实现的就是这么一个效果。  </p>
<p>但是我们看一下调用，我们调用<code>counter</code>函数后返回一个函数对象，按道理，<code>counter</code>函数已经调用完，就应该清除了函数内的所有变量，也就是代码中的<code>i</code>变量理应没了。但是实际上显示的效果就是这个变量被返回的函数对象给记住了，因此上述代码就能够如预期结果那样执行起来了。  </p>
<p>从技术层面来说(青涩难懂那种)，闭包就是:  </p>
<blockquote>
<p>闭包是由函数及其相关的引用环境组合而成的实体(即：闭包=函数+引用环境)(想想Erlang的外层函数传入一个参数a, 内层函数依旧传入一个参数b, 内层函数使用a和b, 最后返回内层函数)</p>
</blockquote>
<h1 id="修饰器"><a href="#修饰器" class="headerlink" title="修饰器"></a>修饰器</h1><p>接下来开始进入主题，讲讲什么是修饰器，修饰器是Python的一种语法特征，简单说就是函数<code>decorator</code>接收参数<code>func</code>并返回一个参数与<code>func</code>函数参数一样的函数<code>wrapper</code>,我们就可以拿<code>decorator</code>去修饰参数与<code>func</code>函数参数一致的函数了。说得有点饶了，下面看看代码上的描述吧！  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(arg1, arg2)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">(arg1, arg2)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>对着上面的代码理解就比较清晰了。实际上不单单是函数对象，只要是执行<code>callable</code>返回<code>True</code>的对象都可以作为修饰器或者被修饰。  </p>
<p>这里接着上面的代码，我们调用一下<code>my_func</code>函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_func(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 等效为没有使用修饰器@decorator时的下面语句</span></span><br><span class="line"><span class="comment"># decorator(my_func)(10, 10)</span></span><br></pre></td></tr></table></figure>

<p>到这里，修饰器的用法的介绍完了，完了，完了…其实很多使用方法归结起来就是看你如何构造成上面所描述的规则吧，下面看看一些常用的例子吧！  </p>
<h1 id="日志打引器"><a href="#日志打引器" class="headerlink" title="日志打引器"></a>日志打引器</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logger</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">"[Called]  %s"</span> % func.__name__)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        func(*args,**kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logger</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"test"</span>)</span><br><span class="line"></span><br><span class="line">my_func()</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># [Called]  my_func</span></span><br><span class="line"><span class="comment"># test</span></span><br></pre></td></tr></table></figure>

<p>这里说一下的就是<code>wrapper</code>，也就是返回的函数，把参数写为<code>*args, **kwargs</code>表示可以接收任何参数。</p>
<h1 id="带参数的修饰器"><a href="#带参数的修饰器" class="headerlink" title="带参数的修饰器"></a>带参数的修饰器</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pow</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">exec</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> x**a</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">exec</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@pow(2)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(square(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等效为没加修饰器时的pow(2)(square)(4)</span></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># 16</span></span><br></pre></td></tr></table></figure>

<p>上面代码时实现了一个求二次幂的函数，我们来分析一下，按前面所说的，<code>@</code>后面的是一个参数为函数的函数，我们可以看到，<code>pow(2)</code>返回的结果就是所有的那个函数，所以带参数的修饰器还是很好实现的。本人测试了一下，嵌套三层才返回就不行了。如下面的代码就会提示有错了。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pow</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">exec</span><span class="params">(x)</span>:</span></span><br><span class="line">                <span class="keyword">return</span> x**a</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">exec</span></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> test</span><br><span class="line"></span><br><span class="line"><span class="meta">@pow(2)()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(square(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<p>上面代码运行的时候就会提示<code>@pow(2)()</code>这一句有语法错误了。但是我们可以改一下让它运行起来， 如下  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pow</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">exec</span><span class="params">(x)</span>:</span></span><br><span class="line">                <span class="keyword">return</span> x**a</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">exec</span></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> test</span><br><span class="line">decorator = pow(<span class="number">2</span>)()</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(square(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># 16</span></span><br></pre></td></tr></table></figure>

<h1 id="用类作为修饰器"><a href="#用类作为修饰器" class="headerlink" title="用类作为修饰器"></a>用类作为修饰器</h1><p>用类作为修饰器我们必须实现<code>__init__</code>和<code>__call__</code>这两个内置函数。我们先用下面代码来简单分析一下。  </p>
<p>先看一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(callable(test))</span><br><span class="line">print(callable(test()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure>

<p>再看一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(callable(test))</span><br><span class="line">print(callable(test()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p>可以看到，类本身是一个<code>callable</code>对象，而实现了<code>__call__</code>的类的实例也是一个<code>callable</code>对象，这样我们就很好办了。在调用的时候，以类<code>test</code>为例，<code>test()</code>传入的是<code>__init__</code>的参数，<code>test()()</code>后面括号传入的是<code>__call__</code>的参数。因此我们举几个例子。  </p>
<h2 id="不到参数的类修饰器"><a href="#不到参数的类修饰器" class="headerlink" title="不到参数的类修饰器"></a>不到参数的类修饰器</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logger</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.__func = func</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"[Called] %s"</span> % self.__func.__name__)</span><br><span class="line">        self.__func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">@logger</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"test"</span>)</span><br><span class="line"></span><br><span class="line">my_func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># [Called] my_func</span></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line"><span class="comment"># 等效为不带修饰器时的logger(my_func)()</span></span><br></pre></td></tr></table></figure>

<h2 id="带参数的类修饰器"><a href="#带参数的类修饰器" class="headerlink" title="带参数的类修饰器"></a>带参数的类修饰器</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pow</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        self.__a = a</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self,func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> x ** self.__a</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@pow(2)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(square(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># 16</span></span><br></pre></td></tr></table></figure>

<h1 id="偏函数作为修饰器"><a href="#偏函数作为修饰器" class="headerlink" title="偏函数作为修饰器"></a>偏函数作为修饰器</h1><h2 id="什么是偏函数"><a href="#什么是偏函数" class="headerlink" title="什么是偏函数"></a>什么是偏函数</h2><p>个人理解，也数学上的偏函数理解有点像，就是固定某些变量的值，得到关于余下其他变量的函数，下面是例子。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pow</span><span class="params">(x, a)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x ** a</span><br><span class="line"></span><br><span class="line">square = functools.partial(pow, a=<span class="number">2</span>)</span><br><span class="line">print(square(<span class="number">4</span>))</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># 16</span></span><br></pre></td></tr></table></figure>

<h2 id="偏函数修饰器"><a href="#偏函数修饰器" class="headerlink" title="偏函数修饰器"></a>偏函数修饰器</h2><p>根据上面的分析，我们可以用偏函数得到一个返回值和参数都是函数的函数，再用这个函数去修饰其他函数，下面举个例子。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pow</span><span class="params">(func, a)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> args[<span class="number">0</span>] ** a</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@functools.partial(pow, a=2)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(square(<span class="number">4</span>)))</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># 16</span></span><br></pre></td></tr></table></figure>

<h1 id="利用修饰器修饰类"><a href="#利用修饰器修饰类" class="headerlink" title="利用修饰器修饰类"></a>利用修饰器修饰类</h1><p>我们上面已经知道，类其实是一个<code>callable</code>对象，按道理应该可以被修饰器来修饰。我们按着修饰器的要求，构造一个修饰类的修饰器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(cls)</span>:</span></span><br><span class="line">    print(<span class="string">"decorator"</span>)</span><br><span class="line">    <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pow</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, a)</span>:</span></span><br><span class="line">        print(<span class="string">"init"</span>)</span><br><span class="line">        self.__x = x</span><br><span class="line">        self.__a = a</span><br><span class="line">    </span><br><span class="line">pow(<span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># decorator</span></span><br><span class="line"><span class="comment"># init</span></span><br><span class="line"><span class="comment"># 效果等效于不用修饰器时的decorator(pow)(4, 2)</span></span><br></pre></td></tr></table></figure>

<p>哈哈，从上面结果看还是验证了我们的想法。下面我们构造一个带参数的。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pow</span><span class="params">(a)</span>:</span></span><br><span class="line">    print(<span class="string">"decorator"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls(a)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@pow(2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">square</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        print(<span class="string">"init"</span>)</span><br><span class="line">        self.__x = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__x ** a</span><br><span class="line">    </span><br><span class="line">print(square(<span class="number">4</span>))</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># decorator</span></span><br><span class="line"><span class="comment"># init</span></span><br><span class="line"><span class="comment"># 16</span></span><br><span class="line"><span class="comment"># 效果等效于不带修饰器时的pow(2)(square)(4)</span></span><br></pre></td></tr></table></figure>

<p>看来掌握了修饰器的规则，那么万变就不离其宗了。  </p>
<h1 id="利用多个修饰器"><a href="#利用多个修饰器" class="headerlink" title="利用多个修饰器"></a>利用多个修饰器</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">"func1"</span>)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">"func2"</span>)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">"func3"</span>)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="meta">@func1</span></span><br><span class="line"><span class="meta">@func2</span></span><br><span class="line"><span class="meta">@func3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"test"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># func3</span></span><br><span class="line"><span class="comment"># func2</span></span><br><span class="line"><span class="comment"># func1</span></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line"><span class="comment"># 效果等效为不用修饰器时的func1(func2(func3(test)))()</span></span><br></pre></td></tr></table></figure>

<h1 id="内置修饰器"><a href="#内置修饰器" class="headerlink" title="内置修饰器"></a>内置修饰器</h1><h2 id="wraps"><a href="#wraps" class="headerlink" title="wraps"></a>wraps</h2><p>我们先看一下前面的例子，经过修饰器修饰后的函数还是原来的函数吗？  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logger</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logger</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"function name:"</span>, my_func.__name__)</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># wrapper</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到，经过修饰器修饰后，函数名就变了，理解起来也就是，经过修饰器后，实际上发生了这么一个事，即被修饰的函数等同于<code>my_func = logger(my_func)</code>，因此也就有了输出的函数名为<code>wrapper</code>,怎么解决这问题呢？也就是经过修饰器后函数名不变。看下面的例子，用到了内置修饰器<code>wraps</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logger</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logger</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"function name:"</span>, my_func.__name__)</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># my_func</span></span><br></pre></td></tr></table></figure>

<h2 id="property"><a href="#property" class="headerlink" title="property"></a>property</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, age)</span>:</span></span><br><span class="line">        self.__age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self, age)</span>:</span></span><br><span class="line">        self.__age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> self.__age</span><br><span class="line"></span><br><span class="line">s = Student(<span class="number">10</span>)</span><br><span class="line">print(s.age)</span><br><span class="line">s.age = <span class="number">20</span></span><br><span class="line">print(s.age)</span><br><span class="line"><span class="keyword">del</span> s.age</span><br><span class="line"><span class="comment"># print(s.age) # 在删除之后再执行这句的话会报错，说Student没有age属性</span></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># 10</span></span><br><span class="line"><span class="comment"># 20</span></span><br></pre></td></tr></table></figure>

<p>可以看到，我们用<code>@property</code>修饰器修饰函数后，函数名会自动变成了类的属性，如上面代码所示，我们将类的变量设置为私有的，但是用了修饰器之后，我们可以像公有成员变量一样使用，同时我们可以在相应的函数中对变量的修改和访问进行限制，可以说是相当便利的。  </p>
<h1 id="staticmethod和classmethod"><a href="#staticmethod和classmethod" class="headerlink" title="staticmethod和classmethod"></a>staticmethod和classmethod</h1><p>我们先看一下代码，如下  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_func</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"static method"</span>)</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_method</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(cls == Student)</span><br><span class="line">        print(<span class="string">"class method"</span>)</span><br><span class="line"></span><br><span class="line">Student.static_func()</span><br><span class="line">Student.class_method()</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># static method</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># class method</span></span><br></pre></td></tr></table></figure>

<p>可以看到，用了修饰器<code>@staticmethod</code>和<code>@classmethod</code>修饰的类函数属于类本身，可以直接利用类进行调用，而不需要进行实例化。另外，我们可以看到它们都不用传如参数<code>self</code>，但是区别在于<code>classmethod</code>要传入<code>cls</code>参数，也就是相应的类。我们从<code>cls == Student</code>的结果可以看到，<code>cls</code>其实就是<code>Student</code>。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>一句话，函数<code>decorator</code>接收参数<code>func</code>并返回一个参数与<code>func</code>函数参数一样的函数<code>wrapper</code>,我们就可以拿<code>decorator</code>去修饰参数与<code>func</code>函数参数一致的函数了</strong>  </p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://book.pythontips.com/en/latest/decorators.html#decorators" target="_blank" rel="noopener">Decorators — Python Tips 0.1 documentation</a></li>
<li><a href="https://www.cnblogs.com/JohnABC/p/4076855.html" target="_blank" rel="noopener">Python-闭包详解</a></li>
<li><a href="https://mp.weixin.qq.com/s/8z92pbhJV1ybfE6YZfvOuw" target="_blank" rel="noopener">没看完这11 条，别说你精通 Python 装饰器</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Decorator</tag>
        <tag>Closure</tag>
      </tags>
  </entry>
  <entry>
    <title>理解Python的继承</title>
    <url>/2020/09/15/python_mro_and_inherit/</url>
    <content><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>本文主要从语言特性和原理上阐述Python中的继承。关于继承，主要涉及到的就是属性的读写以及函数的调用二义性问题，这里不论及关于底层的对象存储相关的原理（主要是我也不懂）。另外提到的原理只针对Python2.7，这里值得一提的是，测试用例是在Pyhon2.7.12上面编写和运行的。因为Python不同版本中存在一定差异，Python3中在继承上也做了一定的修改，但这些都不影响去理解Python中较为一般性的原理。当然，本文写的这些东西一个是方便对  Python继承有更深入的认识，另一方面是为了在开发一些框架或者稍微底层通用一点的库提供参考。在实际业务开发中最好就不用到这些了，及其容易入坑。  </p>
<h1 id="新式类与古典类"><a href="#新式类与古典类" class="headerlink" title="新式类与古典类"></a><a href="https://docs.python.org/2/reference/datamodel.html#new-style-and-classic-classes" target="_blank" rel="noopener">新式类与古典类</a></h1><p>Python中有新式类和古典类之分，Python2.2前都是只有古典类，而在Python2.2及其以上的版本，都引进了新式类，在Python3前，新式类和古典类共同存在，而Python3之后则只保留了新式类。  </p>
<p>新式类和古典类存在较大的差异，新式类提供了统一的对象模型，新式类和古典类有哪些差别或者新式类有哪些特征可以参考<a href="https://www.python.org/doc/newstyle/" target="_blank" rel="noopener">这里</a>。新式类和古典类在创建上区别就是，新式类需要继承自一个新式类或者直接继承<code>object</code>来创建，而古典类则不继承任何类或者继承其他古典类来创建。它们之间存在一个显著的差异就是，在古典类中，一个实例对象x的x.__class__和type(x)是不一样的（这里不考虑手动修改对象__class__属性的情况），例如下面的代码：  </p>
<p>古典类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> <span class="keyword">pass</span></span><br><span class="line">x = A()</span><br><span class="line"><span class="keyword">print</span> x.__class__</span><br><span class="line"><span class="keyword">print</span> type(x)</span><br><span class="line"><span class="comment"># 输出为：</span></span><br><span class="line"><span class="comment"># __main__.A</span></span><br><span class="line"><span class="comment"># &lt;type 'instance'&gt;</span></span><br></pre></td></tr></table></figure>

<p>新式类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line">x = A()</span><br><span class="line"><span class="keyword">print</span> x.__class__</span><br><span class="line"><span class="keyword">print</span> type(x)</span><br><span class="line"><span class="comment"># 输出为：</span></span><br><span class="line"><span class="comment"># &lt;class '__main__.A'&gt;</span></span><br><span class="line"><span class="comment"># &lt;class '__main__.A'&gt;</span></span><br></pre></td></tr></table></figure>

<p>也就是说，古典类都是内置类型<code>instance</code>的实例，于是在古典类中，两个实例对象a和b之间，<code>type(a) == type(b)</code>总是为<code>True</code>。这些就是Python中古典类和新式类的一些差异，当然，更深层次的东西涉及到的就是两种不同的对象模型了。   </p>
<h1 id="方法解析顺序MRO（Method-Resolution-Order）"><a href="#方法解析顺序MRO（Method-Resolution-Order）" class="headerlink" title="方法解析顺序MRO（Method Resolution Order）"></a>方法解析顺序MRO（Method Resolution Order）</h1><p>在Python中讲到继承，必然就会涉及到MRO。所谓MRO，简单说就是指在Python中对象调用函数的查找顺序，根据MRO，Python就可以准确调用到正确的函数而不发生歧义。上面提到的古典类与新式类中的MRO有所不同，古典类的MRO搜索是采用自左向右的深度优先方法。而新式类则是在古典类的基础上做了一点的修改和优化，采用的是C3 MRO搜索方法。下面简单介绍一下C3 MRO算法。  </p>
<h2 id="C3-MRO算法"><a href="#C3-MRO算法" class="headerlink" title="C3 MRO算法"></a>C3 MRO算法</h2><p>首先定义一下用的的一些符号。<br>$C_1C_2…C_N$：表示类列表，等同于$[C_1, C_2, …, C_N]$；<br>对于上没的列表来说，有：<br>$$head=C_1$$<br>$$tail=C_2…C_N$$<br>$$C+(C_1C_2…C_N)=CC_1C_2…C_N$$<br>假设有一个类$C$集成自$B_1$，$B_2$，$…$，$B_N$，现在我们需要确定类$C$的MRO类列表(也就是类$C$的线性化)，可以根据以下步骤唯一确定。  </p>
<p>记$L[C]$表示类$C$的线性化，同时又有$L[C]=L[C(B_1…B_N)]$，则 类$C$的线性化类列表，该列表由类$C$，类$C$各个父类线性化类列表的合并，以及类$C$的父类这三个部分组成。可以表示为<br>$$L[C]=L[C(B_1…B_N)]=C+merge(L[B_1], …, L[B_N], B_1…B_N)$$<br>特别的，有<br>$$L[object]=object$$<br>现在只需要确定$merge$如何进行就可以了，$merge$需要对$N+1$个列表进行操作得到一个新的列表。我们记这$N+1$个列表分别为$L_1=L[B_1]$，…，$L_N=L[B_N]$，$L_{N+1}=B_1…B_N$，同时记$head_i$为$L_i$的$head$，$tail_i$为$L_i$的$tail$。于是$merge$步骤伪代码为：<br><img src="/2020/09/15/python_mro_and_inherit/c3mro.svg" alt="C3 MRO伪代码"><br>上面的伪代码仅仅表示出了C3 MRO算法的思路，具体实现可能就不是最优的了。这算法描述起来就是，$merge$多个类列表的时候，从左到右的列表中，依次取出每个列表的$head$，如果该$head$不在其余所有列表的$tail$中，则取出该$head$，然后在每个列表中都删去该$head$类（存在的话其实都是响应列表的第一个元素），然后继续按前面步骤从第一个列表重新开始再取出一个，如果$head$在其它的$tail$中存在，则取下一个列表的$head$进行同样的步骤，直到可以满足条件取出一个为止。如果最后一个列表的$head$也无法满足，则$merge$操作失败，也就是说无法完成线性化。如果每一次都能提取出一个类，则最终提取出来object后终止，从而完成$merge$操作。<br>另外相对于单继承，有<br>$$L[C(B)]=C+merge(L[B],B)=C+L[B]$$ </p>
<p>下面举个例子，有如下继承关系的类：<br><img src="/2020/09/15/python_mro_and_inherit/example_1.svg" alt="正常继承关系实例"><br>现在我们要算出类A的MRO，则根据上面所述的算法，有  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L[O] = O</span><br><span class="line"></span><br><span class="line">L[D(O)] = D + merge(L[O], O) = DO</span><br><span class="line">L[E(O)] = E + merge(L[O], O) = EO</span><br><span class="line">L[F(O)] = F + merge(L[O], O) = FO</span><br><span class="line"></span><br><span class="line">L[B(DE)] = B + merge(L[D], L[E], DE)</span><br><span class="line">         = B + merge(DO, EO, DE)</span><br><span class="line">         = B + D + merge(O, EO, E)</span><br><span class="line">         = B + D + E + merge(O, O)</span><br><span class="line">         = BDEO</span><br><span class="line"></span><br><span class="line">L[C(DF)] = C + merge(L[D], L[F], DF)</span><br><span class="line">         = C + merge(DO, FO, DF)</span><br><span class="line">         = C + D + merge(O, FO, F)</span><br><span class="line">         = C + D + F + merge(O, O)</span><br><span class="line">         = BDFO</span><br><span class="line"></span><br><span class="line">L[A(BC)] = A + merge(L[B], L[C], BC)</span><br><span class="line">         = A + merge(BDEO, CDFO, BC)</span><br><span class="line">         = A + B + merge(DEO, CDFO, C)</span><br><span class="line">         = A + B + C + merge(DEO, DFO)</span><br><span class="line">         = A + B + C + D + merge(EO, FO)</span><br><span class="line">         = A + B + C + D + E + merge(O, FO)</span><br><span class="line">         = A + B + C + D + E + F + merge(O, O)</span><br><span class="line">         = ABCDEFO</span><br></pre></td></tr></table></figure>

<p>从而得到类A的MRO类列表为ABCDEFO。下面再举一个C3 MRO算法执行失败的情况，也就是无法解析出一个MRO列表，或者说这种继承关系将会产生异常。<br>假如有X和Y继承自object，A继承自X和Y，B继承自Y和X，也就是继承顺序相反，而有C继承自A和B，则根据前面所述的算法，有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L[X] = XO</span><br><span class="line">L[Y] = YO</span><br><span class="line">L[A] = AXYO</span><br><span class="line">L[B] = BYXO</span><br><span class="line"></span><br><span class="line">L[C] = C + merge(L[A], L[B], AB)</span><br><span class="line">     = C + merge(AXYO, BYXO, AB)</span><br><span class="line">     = C + A + merge(XYO, BYXO, B)</span><br><span class="line">     = C + A + B + merge(XYO, YXO)</span><br></pre></td></tr></table></figure>

<p>当上面执行到merge(XYO, YXO)时，第一个列表获取head为X，但是X在第二个列表的tail中存在，因此进而获取第二个列表的head为Y，但是Y在第一个列表的tail中存在，到此没有跟多列表执行下去了，因此算法终止，返回异常。因此这种继承关系是不太好的，实际上在Python中直接会抛出异常。  </p>
<p>Python中可以利用类的<code>mro()</code>函数或者<code>__mro__</code>属性或取其MRO搜索列表。  </p>
<p>上面的的例子中，用写成Python程序如下：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正常继承关系</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(D, E)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(D, F)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(B, C)</span>:</span> <span class="keyword">pass</span></span><br><span class="line">A.mro()</span><br><span class="line"><span class="comment"># [__main__.A,</span></span><br><span class="line"><span class="comment">#  __main__.B,</span></span><br><span class="line"><span class="comment">#  __main__.C,</span></span><br><span class="line"><span class="comment">#  __main__.D,</span></span><br><span class="line"><span class="comment">#  __main__.E,</span></span><br><span class="line"><span class="comment">#  __main__.F,</span></span><br><span class="line"><span class="comment">#  object]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 异常继承关系</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(X, Y)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(Y, X)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A, B)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># TypeErrorTraceback (most recent call last)</span></span><br><span class="line"><span class="comment">#  in ()</span></span><br><span class="line"><span class="comment">#       3 class A(X, Y): pass</span></span><br><span class="line"><span class="comment">#       4 class B(Y, X): pass</span></span><br><span class="line"><span class="comment"># ----&gt; 5 class C(A, B): pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TypeError: Error when calling the metaclass bases</span></span><br><span class="line"><span class="comment">#     Cannot create a consistent method resolution</span></span><br><span class="line"><span class="comment"># order (MRO) for bases Y, X</span></span><br></pre></td></tr></table></figure>

<h1 id="多继承与super"><a href="#多继承与super" class="headerlink" title="多继承与super"></a>多继承与super</h1><p>利用C3 MRO算法，就可以确定Python中继承关系的函数调用搜索顺序了。只要一个继承关系中能够确定MRO，那么这个继承关系就是合法的。Python支持多继承，也就是一个类可以同时继承自多个其他类。讲到多继承，那么就会讲到super。猛戳<a href="https://docs.python.org/2/library/functions.html#super" target="_blank" rel="noopener">这里</a>可以查看官网文档。下面，来了解下super是啥，能干啥用。  </p>
<h2 id="什么是super"><a href="#什么是super" class="headerlink" title="什么是super"></a>什么是super</h2><p>对super做一下类型检查，可以看到super是一个类类型（super类型），实例化后可以得到一个super对象。如下所示：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> type(super)</span><br><span class="line"><span class="keyword">print</span> super(object)</span><br><span class="line"><span class="keyword">print</span> type(super(object))</span><br><span class="line"><span class="comment"># &lt;type 'type'&gt;</span></span><br><span class="line"><span class="comment"># &lt;super: &lt;class 'object'&gt;, NULL&gt;</span></span><br><span class="line"><span class="comment"># &lt;type 'super'&gt;</span></span><br></pre></td></tr></table></figure>

<p>从<a href="https://docs.python.org/2/library/functions.html#super" target="_blank" rel="noopener">官方文档</a>可以获悉，实例化super之后得到的是一个代理对象，所谓代理对象，就是指其代理某个对象执行一些操作，这些操作等同于被代理的对象自己亲自执行的效果。利用super提供的代理对象，可以方便地调用一个类的父类或者兄弟类的函数。此外，super仅仅提供了这样的一种机制，不一定要在类里面实例化super。例如：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调用父类函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"this is parent"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Parent)</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"this is child"</span></span><br><span class="line">Child.test()</span><br><span class="line">super(Child, Child).test()</span><br><span class="line"><span class="comment"># this is child</span></span><br><span class="line"><span class="comment"># this is parent</span></span><br></pre></td></tr></table></figure>

<p>可以看到，利用super得到的代理对象准确的调用了父类函数。因此，得了解super是如何准确调用父类函数的，两个参数有分别代表什么意思？  </p>
<h2 id="理解super的参数与调用规则"><a href="#理解super的参数与调用规则" class="headerlink" title="理解super的参数与调用规则"></a>理解super的参数与调用规则</h2><p>从<a href="https://docs.python.org/2/library/functions.html#super" target="_blank" rel="noopener">官网说明文档</a>可以知道，super的两个参数是有要求的，必须满足条件：<strong>第二参数必须是第一参数自己或者其派生类的类类型或者实例对象</strong>，可以这么记一下：super(parent, child)。其中第二参数就是super实例化后代理的对象，也就是代理child执行操作。而第一个参数就是确定了其函数调用的界线。具体的调用规则可以这么理解，假设：  </p>
<ul>
<li>parent的MRO为[A, B, C, D, E, …]</li>
<li>child（如果为实例则type(child)）的MRO为[C, D, E, …]  </li>
</ul>
<p>那么，super(parent, child)调用函数的MRO为[D, E, …]。具体的就是，<strong>super是child的代理，其函数查找MRO为child（如果是实例指的就是其类型）的MRO中parent后面的部分。</strong> 这就是super调用函数的规则。例如：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> self.__class__</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"this is A"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> self.__class__</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"this is B"</span></span><br><span class="line">b = B()</span><br><span class="line">super(B, b).test()</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># &lt;class '__main__.B'&gt;</span></span><br><span class="line"><span class="comment"># this is A</span></span><br></pre></td></tr></table></figure>

<p>上面例子可以看出来，super(B, b)代理了b对象，执行了A中的test函数。（可以看到A中test函数中打印的self.__class__为类B，因此可以知道实际代理了b执行了其父类的函数）  </p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上就是关于Python中多继承的一些细节，了解清楚之后就可以设计相对比较复杂的继承关系（不过不建议，简单能解决就简单搞），利用类的MRO搜索列表，就可以很清晰知道一个对象具体调用了哪个函数了。  </p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>多继承</tag>
        <tag>MRO</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow基本概念——How it work?</title>
    <url>/2019/10/01/tensorflow_basic_how_it_work/</url>
    <content><![CDATA[<h1 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h1><p>介绍TensorFlow基本概念，包括<code>Tensor</code>，<code>shape</code>，<code>Type</code>，<code>Graph</code>，<code>Session</code>和<code>Operation</code>。</p>
<h1 id="什么是张量-Tensor"><a href="#什么是张量-Tensor" class="headerlink" title="什么是张量(Tensor)"></a>什么是张量(Tensor)</h1><p>在TensorFlow中，所有的运算都与张量有关。一个<code>张量(Tensor)</code>就是可以表示任何数据类型的一个向量(vector)或者矩阵(matrix)。张量中值的<code>类型(Type)</code>和<code>形状(shape)</code>是明确的，所谓形状，指的是矩阵的维数。  </p>
<p>张量可以从输入或者运算结果得到。在TensorFlow中，任何<code>操作(operation)</code>都是在<code>图(Graph)</code>中进行的，图就是一个以此连接的操作节点和边的集合，每一个操作称为<code>op节点(op nade)</code>，并且它们相互连接在一起。图概括了节点和边，就像画布概括了里面画的形状一样。然而，在图里面是不显示值的，只是展示了节点和边的连接方式。而所谓边，其实就是一个张量，用这个张量的数据去填充后续的操作。</p>
<p>在机器学习中，模型输入的是特征向量(feature vectors)。一个特征向量可以是任何数据类型，特征向量也通常是张量的首次填充的值。这些值通过张量将<code>流(flow)</code>进op节点，同时，节点的操作结果也将创建一个新的张量，流到下一个op节点去。在这里的所有操作都可以在图中可视化。</p>
<h1 id="张量的表示"><a href="#张量的表示" class="headerlink" title="张量的表示"></a>张量的表示</h1><p>在TensorFlow中，张量就是n维特征向量的集合。比如，我们有一个2×3的矩阵，在TensorFlow中表示该矩阵为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br></pre></td></tr></table></figure>

<p>我们创建一个3维的矩阵，直观地看如下所示<br><img src="/2019/10/01/tensorflow_basic_how_it_work/3d_matrix_view.png" alt="可视化3维矩阵"><br>在TensorFlow中可以表示为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line">  [<span class="number">3</span> <span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line"> [[<span class="number">5</span> <span class="number">6</span>]</span><br><span class="line">  [<span class="number">7</span> <span class="number">8</span>]]]</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>一个张量表示一个标量或者更高维的矩阵，更高维的矩阵就是比较难直观可视化罢了。</p>
<h1 id="张量的种类"><a href="#张量的种类" class="headerlink" title="张量的种类"></a>张量的种类</h1><p>在TensorFlow中，所有计算都是通过一个或多个张量进行的。一个张量包括三个属性：</p>
<ul>
<li>唯一标示(name)</li>
<li>维度(shape)</li>
<li>数据类型(dtype)</li>
</ul>
<p>在TensorFlow中执行的每一个操作都与张量有关。你可以创建的张量主要有4种类型：</p>
<ul>
<li>tf.Variable</li>
<li>tf.constant</li>
<li>tf.placeholder</li>
<li>tf.SpareTensor</li>
</ul>
<h1 id="常亮-constants"><a href="#常亮-constants" class="headerlink" title="常亮(constants)"></a>常亮(constants)</h1><p><strong>注意：</strong>后面默认代码已经导入TensorFlow，即开头包含<code>import tensorflow as tf</code><br>可以用tf.constant()来创建一个张量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.constant(value, dtype, name=<span class="string">""</span>)</span><br></pre></td></tr></table></figure>

<p>参数分别是：<br><code>value</code>: 定义张量的值，可选项<br><code>dtype</code>: 定义数据类型，可以是<br>&emsp;&emsp;<code>tf.string</code>: 字符型<br>&emsp;&emsp;<code>tf.float32</code>: 浮点型<br>&emsp;&emsp;<code>tf.int16</code>: 整型<br><code>name</code>: 张量的名称，可选项。默认为<code>Const_1:0</code>  </p>
<p>创建0维张量:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r1 = tf.constant(<span class="number">1</span>, tf.int16) </span><br><span class="line">print(r1)</span><br><span class="line"><span class="comment">#output：</span></span><br><span class="line"><span class="comment">#Tensor("Const:0", shape=(), dtype=int16)</span></span><br></pre></td></tr></table></figure>

<p><img src="/2019/10/01/tensorflow_basic_how_it_work/output_tensor_view.png" alt="输出张量说明"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r2 = tf.constant(<span class="number">1</span>, tf.int16, name = <span class="string">"my_scalar"</span>) </span><br><span class="line">print(r2)</span><br><span class="line"><span class="comment">#output：</span></span><br><span class="line"><span class="comment">#Tensor("myscalar:0", shape=(), dtype=int16)</span></span><br></pre></td></tr></table></figure>

<p>创建1维张量:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r1_vector = tf.constant([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>], tf.int16)</span><br><span class="line">print(r1_vector)</span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"><span class="comment">#Tensor("myscalar:0", shape=(), dtype=int16)</span></span><br></pre></td></tr></table></figure>

<p>可以看到输出形状只包含了一列。<br>我们可以创建2维张量如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r2_matrix = tf.constant([ [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">                          [<span class="number">3</span>, <span class="number">4</span>] ],tf.int16)</span><br><span class="line">print(r2_matrix)</span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"><span class="comment">#Tensor("Const_2:0", shape=(2, 2), dtype=int16)</span></span><br></pre></td></tr></table></figure>

<p>创建3维张量如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r3_matrix = tf.constant([ [[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">                           [<span class="number">3</span>, <span class="number">4</span>], </span><br><span class="line">                           [<span class="number">5</span>, <span class="number">6</span>]] ], tf.int16)</span><br><span class="line">print(r3_matrix)	</span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"><span class="comment">#Tensor("Const_3:0", shape=(1, 3, 2), dtype=int16)</span></span><br></pre></td></tr></table></figure>

<h1 id="张量的形状-shape"><a href="#张量的形状-shape" class="headerlink" title="张量的形状(shape)"></a>张量的形状(shape)</h1><p>在你打印张量的时候，TensorFlow会根据你的输入判断出一个形状(shape)。你可以利用张量的形状属性获取张量的形状。如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m_shape = tf.constant([ [<span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">                        [<span class="number">12</span>, <span class="number">13</span>],</span><br><span class="line">                        [<span class="number">14</span>, <span class="number">15</span>] ]                      </span><br><span class="line">                     ) </span><br><span class="line">m_shape.shape</span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"><span class="comment">#TensorShape([Dimension(3), Dimension(2)])</span></span><br></pre></td></tr></table></figure>

<p>TensorFlow提供了快速创建元素为0或者1的多维张量。比如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(tf.zeros([<span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line"><span class="comment">#Tensor("zeros_1:0", shape=(2, 3), dtype=float32)</span></span><br><span class="line">print(tf.ones([<span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line"><span class="comment">#Tensor("ones:0", shape=(2, 3), dtype=float32)</span></span><br></pre></td></tr></table></figure>

<h1 id="张量的数据类型"><a href="#张量的数据类型" class="headerlink" title="张量的数据类型"></a>张量的数据类型</h1><p>接下来讲的是张量的第二个属性——数据类型。一个张量只能有一种数据类型，可以利用下面的方式查看张量的数据类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = tf.zeros(<span class="number">10</span>)</span><br><span class="line">print(t1.dtype)</span><br><span class="line"><span class="comment">#output</span></span><br><span class="line"><span class="comment">#&lt;dtype: 'float32'&gt;</span></span><br></pre></td></tr></table></figure>

<p>有时候我们想改变张量的数据类型，我们可以用<code>tf.cast</code>方法进行类型转换。比如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">type_float = tf.constant(<span class="number">3.123456789</span>, tf.float32)</span><br><span class="line">type_int = tf.cast(type_float, dtype=tf.int32)</span><br><span class="line">print(type_float.dtype)</span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"><span class="comment">#&lt;dtype: 'float32'&gt;</span></span><br><span class="line">print(type_int.dtype)</span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"><span class="comment">#&lt;dtype: 'int32'&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果我们在创建张量时没有指定数据类型，TensorFlow将为我们自动选择数据类型。</p>
<h1 id="创建操作op"><a href="#创建操作op" class="headerlink" title="创建操作op"></a>创建操作op</h1><p>TensorFlow包含了所有基本运算操作。我们先以简单的开始，我们演示一下利用TensorFlow提供的方法计算一个数的平方根。如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = tf.constant([<span class="number">2.0</span>], dtype=tf.float32)</span><br><span class="line">print(tf.sqrt(x))</span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"><span class="comment">#Tensor("Sqrt:0", shape=(1,), dtype=float32)</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>输出返回的是一个张量对象，而不是根号2的结果。这里仅仅是将定义的一个张量打印出来，而实际上还没有进行运算。在TensorFlow中如何执行运算后面将介绍到。  </p>
<p>以下是TensorFlow中常见的操作。</p>
<ul>
<li><code>tf.add(a, b)</code>加法</li>
<li><code>tf.substract(a, b)</code>减法</li>
<li><code>tf.multiply(a, b)</code>乘法</li>
<li><code>tf.div(a, b)</code>除法</li>
<li><code>tf.pow(a, b)</code>幂</li>
<li><code>tf.exp(a)</code>自然指数</li>
<li><code>tf.sqrt(a)</code>平方根</li>
</ul>
<p>例如(add，multiply)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensor_a = tf.constant([[<span class="number">1</span>,<span class="number">2</span>]], dtype = tf.int32)</span><br><span class="line">tensor_b = tf.constant([[<span class="number">3</span>, <span class="number">4</span>]], dtype = tf.int32)</span><br><span class="line">tensor_add = tf.add(tensor_a, tensor_b)</span><br><span class="line">print(tensor_add)</span><br><span class="line"><span class="comment">#output</span></span><br><span class="line"><span class="comment">#Tensor("Add:0", shape=(1, 2), dtype=int32)</span></span><br><span class="line">tensor_multiply = tf.multiply(tensor_a, tensor_b)</span><br><span class="line">print(tensor_multiply)</span><br><span class="line"><span class="comment">#output</span></span><br><span class="line"><span class="comment">#Tensor("Mul:0", shape=(1, 2), dtype=int32)</span></span><br></pre></td></tr></table></figure>

<h1 id="变量-Variables"><a href="#变量-Variables" class="headerlink" title="变量(Variables)"></a>变量(Variables)</h1><p>前面我们已经知道如何创建张量常量了，但是有时候需要改变一个张量的值，这时候我们就需要张量变量(Variable)了。它将表示一个经常变化的节点。<br>可以利用<code>tf.Variable()</code>或者<code>tf.get_variable()</code>创建一个张量变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.Variable(initial_value, name=<span class="string">""</span>)</span><br></pre></td></tr></table></figure>

<p>参数分别是：<br><code>initial_value</code>: 变量的初始值<br><code>name</code>: 变量的名称，可选  </p>
<p>例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(tf.Variable(<span class="number">3</span>))</span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"><span class="comment">#&lt;tf.Variable 'Variable:0' shape=() dtype=int32_ref&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="占位符-placeholder"><a href="#占位符-placeholder" class="headerlink" title="占位符(placeholder)"></a>占位符(placeholder)</h1><p>在TensorFlow中，占位符就是为了“填”张量的。在应用placeholder的时候，我们需要用到<code>feed_dict</code>方法，这样才会在Session中把placeholder给“填（喂）”上数据。下面我们用<code>tf.placeholder</code>我创建占位符张量，后面我们将学习如何给占位符“喂数据”。<br>语法如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.placeholder(dtype, shape=<span class="literal">None</span>, name=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>参数分别是<br><code>dtype</code>: 张量的数据类型<br><code>shape</code>: 张量的形状，可选，默认将由喂的数据决定<br><code>name</code>: 占位符名称，可选<br>例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_placeholder_a = tf.placeholder(tf.float32, name=<span class="string">"data_placeholder_a"</span>)</span><br><span class="line">print(data_placeholder_a)</span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"><span class="comment">#Tensor("data_placeholder_a:0", dtype=float32)</span></span><br></pre></td></tr></table></figure>

<h1 id="会话-Session"><a href="#会话-Session" class="headerlink" title="会话(Session)"></a>会话(Session)</h1><p>TensorFlow包括了以下3大主要部件：</p>
<ul>
<li>图(Graph)</li>
<li>张量(Tensor)</li>
<li>会话(Session)</li>
</ul>
<p><strong><code>图：</code></strong>图是TensorFlow的基础。所有数学操作(ops)都在图中执行，我们可以想象图就是每一个操作执行所在的工程，每一个节点就代表这些操作，它们可以输入张量或者创建张量。<br><strong><code>张量：</code></strong>一个张量表示的时候操作间流动的数据。创建和流动一个张量如前文所示。<br><strong><code>会话：</code></strong>会话是用来执行图中的操作的。我们需要打开一个会话来对图中的操作进行喂数据，然后在会话里面运行一个操作我们才可以得到正真的输出结果。  </p>
<p>图和会话是相互独立的，我们可以使用后续的计算或者操作来运行一个会话或者获取数值。<br>下面我们举个例子完成下面的内容：</p>
<ul>
<li>创建两个张量</li>
<li>创建一个操作</li>
<li>打开一个会话</li>
<li>打印结果</li>
</ul>
<p><strong>步骤1：</strong>分别创建两个张量x和y</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = tf.constant([<span class="number">2</span>])</span><br><span class="line">y = tf.constant([<span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<p><strong>步骤2：</strong>创建一个x乘y的操作节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">multiply = tf.multiply(x, y)</span><br></pre></td></tr></table></figure>

<p><strong>步骤3：</strong>打开会话执行操作，完成后关闭会话</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sess = tf.Session()</span><br><span class="line">result = sess.run(multiply)</span><br><span class="line">print(result)</span><br><span class="line">sess.close()</span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"><span class="comment">#[8]</span></span><br></pre></td></tr></table></figure>

<p>步骤3也可以这么写，这样的话会话在执行完成后会自动关闭</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">  result = multiply.eval()</span><br><span class="line">  print(result)</span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"><span class="comment">#[8]</span></span><br></pre></td></tr></table></figure>

<p>在会话的上下文中，我们可以用<code>eval()</code>方法来执行操作，它跟<code>run()</code>是等效的，这样的话代码的可读性会更强一些。<br>我们可以打开一个会话查看前文我们创建的张量常量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sess = tf.Session()</span><br><span class="line">print(sess.run(r1))</span><br><span class="line">print(sess.run(r2_matrix))</span><br><span class="line">sess.close()</span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="comment">#[[1 2]</span></span><br><span class="line"><span class="comment"># [3 4]]</span></span><br></pre></td></tr></table></figure>

<p>对于张量变量来说，它默认是空的，即使我们已经创建了它，我们需要对变量进行初始化后才可以使用，我们可以用<code>tf.global_variables_initializer()</code>来一下子初始化全部变量，或者使用<code>tf.variables_initializer()</code>来初始化指定的变量。<br>这里我们举例对变量进行初始化，需要注意的是初始化操作也需要在会话中执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var_a = tf.Variable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">sess.run(tf.global_variables_initializer())</span><br><span class="line">print(sess.run(var_a))</span><br><span class="line">sess.close()</span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"><span class="comment">#[1 2 3]</span></span><br></pre></td></tr></table></figure>

<p>我们要使用占位符的话，执行操作的时候需要对其“喂数据”。例如，下面我们执行占位符所代表数据的平方。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">power_a = tf.pow(data_placeholder_a, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:  </span><br><span class="line">  data = np.random.rand(<span class="number">1</span>, <span class="number">10</span>)  </span><br><span class="line">  print(sess.run(power_a, feed_dict=&#123;data_placeholder_a: data&#125;))</span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"><span class="comment">#[[8.7529367e-01 5.7319117e-01 1.8739136e-02 8.0524582e-01 8.9399856e-01</span></span><br><span class="line"><span class="comment">#  5.5646729e-02 2.9369484e-04 3.0354759e-01 7.3121570e-02 1.2742124e-01]]</span></span><br></pre></td></tr></table></figure>

<h1 id="图-Graph"><a href="#图-Graph" class="headerlink" title="图(Graph)"></a>图(Graph)</h1><p>TensorFlow中所有操作都表示为数据流的方式，图是一种可视化操作如何关联的便捷方法。在图中显示节点(node)和表(edge)，节点就是某一种操作。<br>在图里面将操作和操作所需要的数据进行连接，但是图本身不会展示操作的输出结果，而仅仅是将他们可视化。  </p>
<p>比如说， 假如我们要计算下面这个函数：<br>$$f(x,z)=xz+x^2+z+5$$<br>TensorFlow将创建一个图来执行它，这个就像下图所示那样：<br><img src="/2019/10/01/tensorflow_basic_how_it_work/tensorflow_graph_example.png" alt="Graph示例"><br>在图中可以很清晰的看见张量从起始到终点所经过的路径。实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = tf.Variable([<span class="number">15</span>], dtype=tf.int32)</span><br><span class="line">z = tf.Variable([<span class="number">6</span>], dtype=tf.int32)</span><br><span class="line">c = tf.constant([<span class="number">5</span>], name=<span class="string">"constant"</span>)</span><br><span class="line">square = tf.constant([<span class="number">2</span>], name=<span class="string">"square"</span>)</span><br><span class="line">f = tf.multiply(x, z) + tf.pow(x, square) + z + c</span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">  init.run()</span><br><span class="line">  result = f.eval()</span><br><span class="line">  print(result)</span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"><span class="comment">#[326]</span></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>TensorFlow大致工作如下：</p>
<ul>
<li>图：包含着操作和张量的计算的环境（上下文）</li>
<li>张量：表示图中流动的数据，也就是图中的边</li>
<li>会话：所有操作的最终执行者</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.guru99.com/tensor-tensorflow.html" target="_blank" rel="noopener">TensorFlow Basics: Tensor, Shape, Type, Graph, Sessions &amp; Operators</a></li>
</ul>
]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
        <tag>machine learning</tag>
      </tags>
  </entry>
</search>
